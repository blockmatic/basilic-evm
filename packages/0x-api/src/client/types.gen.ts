// This file is auto-generated by @hey-api/openapi-ts

export type BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE = {
    name: 'BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
    };
};

export type name = 'BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE';

export type INPUT_INVALID = {
    name: 'INPUT_INVALID';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
        /**
         * The list of invalid inputs
         */
        details: Array<{
            /**
             * The input field name
             */
            field: string;
            /**
             * The validation failure reason
             */
            reason: string;
        }>;
    };
};

export type name2 = 'INPUT_INVALID';

export type INSUFFICIENT_BALANCE = {
    name: 'INSUFFICIENT_BALANCE';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
        /**
         * The taker of the transaction
         */
        taker: string;
        /**
         * The sell token
         */
        sellToken: string;
        /**
         * The sell amount
         */
        sellAmount: unknown & string;
        /**
         * The current balance of the taker for the sell token
         */
        balance: unknown & string;
    };
};

export type name3 = 'INSUFFICIENT_BALANCE';

export type INSUFFICIENT_BALANCE_OR_ALLOWANCE = {
    name: 'INSUFFICIENT_BALANCE_OR_ALLOWANCE';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
        /**
         * The hash of the meta-transaction provided by the caller
         */
        metaTransactionHash: string;
        /**
         * The intended signer of the meta-transaction
         */
        taker: string;
        /**
         * The sell token
         */
        sellToken: string;
        /**
         * The sell amount
         */
        sellAmount: unknown & string;
        /**
         * The smaller value of the balance or the allowance of the taker
         */
        minBalanceOrAllowance: unknown & string;
    };
};

export type name4 = 'INSUFFICIENT_BALANCE_OR_ALLOWANCE';

export type INTERNAL_SERVER_ERROR = {
    name: 'INTERNAL_SERVER_ERROR';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
    };
};

export type name5 = 'INTERNAL_SERVER_ERROR';

export type INVALID_SIGNATURE = {
    name: 'INVALID_SIGNATURE';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
        /**
         * The hash of the meta-transaction provided by the caller
         */
        metaTransactionHash: string;
        /**
         * The intended signer of the meta-transaction
         */
        taker: string;
    };
};

export type name6 = 'INVALID_SIGNATURE';

export type INVALID_SIGNER = {
    name: 'INVALID_SIGNER';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
        /**
         * The hash of the meta-transaction provided by the caller
         */
        metaTransactionHash: string;
        /**
         * The intended signer of the meta-transaction
         */
        taker: string;
        /**
         * The signer of the meta-transaction
         */
        signer: string;
    };
};

export type name7 = 'INVALID_SIGNER';

export type META_TRANSACTION_EXPIRY_TOO_SOON = {
    name: 'META_TRANSACTION_EXPIRY_TOO_SOON';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
        /**
         * The hash of the meta-transaction provided by the caller
         */
        metaTransactionHash: string;
        /**
         * The expiry of the meta-transaction provided by the caller in ms
         */
        expiry: unknown & string;
    };
};

export type name8 = 'META_TRANSACTION_EXPIRY_TOO_SOON';

export type META_TRANSACTION_INVALID = {
    name: 'META_TRANSACTION_INVALID';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
        /**
         * The hash of the meta-transaction provided by the caller
         */
        metaTransactionHash: string;
    };
};

export type name9 = 'META_TRANSACTION_INVALID';

export type META_TRANSACTION_STATUS_NOT_FOUND = {
    name: 'META_TRANSACTION_STATUS_NOT_FOUND';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
    };
};

export type name10 = 'META_TRANSACTION_STATUS_NOT_FOUND';

export type PENDING_TRADES_ALREADY_EXIST = {
    name: 'PENDING_TRADES_ALREADY_EXIST';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
        /**
         * The hash of the meta-transaction provided by the caller
         */
        metaTransactionHash: string;
        /**
         * The list of pending meta-transaction hashes for the same taker and sell token
         */
        pendingMetaTransactionHashes: Array<(string)>;
    };
};

export type name11 = 'PENDING_TRADES_ALREADY_EXIST';

export type SELL_AMOUNT_TOO_SMALL = {
    name: 'SELL_AMOUNT_TOO_SMALL';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
        /**
         * The minimum sell amount required for the trade to go through
         */
        minSellAmount: unknown & string;
    };
};

export type name12 = 'SELL_AMOUNT_TOO_SMALL';

export type SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE = {
    name: 'SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
    };
};

export type name13 = 'SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE';

export type TAKER_NOT_AUTHORIZED_FOR_TRADE = {
    name: 'TAKER_NOT_AUTHORIZED_FOR_TRADE';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
    };
};

export type name14 = 'TAKER_NOT_AUTHORIZED_FOR_TRADE';

export type TOKEN_NOT_SUPPORTED = {
    name: 'TOKEN_NOT_SUPPORTED';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
    };
};

export type name15 = 'TOKEN_NOT_SUPPORTED';

export type UNCATEGORIZED = {
    name: 'UNCATEGORIZED';
    message: string;
    data: {
        /**
         * The unique ZeroEx identifier of the request
         */
        zid: string;
    };
};

export type name16 = 'UNCATEGORIZED';

export type SwapPermit2GetPriceData = {
    headers: {
        /**
         * Visit dashboard.0x.org to get your API Key
         */
        '0x-api-key': string;
    };
    query: {
        /**
         * The contract address of the token to buy
         */
        buyToken: string;
        /**
         * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
         */
        chainId: number;
        /**
         * Liquidity sources e.g. Uniswap_V3, SushiSwap, 0x_RFQ to exclude from the provided quote. See https://api.0x.org/sources?chainId=<chain_id> with the desired chain's ID for a full list of sources. Separate multiple sources with a comma
         */
        excludedSources?: string;
        /**
         * The target gas price (in wei) for the swap transaction. If not provided, the default value is based on the 0x gas price oracle
         */
        gasPrice?: string;
        /**
         * The amount of `sellToken` in `sellToken` base units to sell
         */
        sellAmount: string;
        /**
         * The contract address of the token to sell
         */
        sellToken: string;
        /**
         * The maximum acceptable slippage of the `buyToken` in Bps. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100Bps
         */
        slippageBps?: number;
        /**
         * The amount in Bps of the `swapFeeToken` to charge and deliver to the `swapFeeRecipient`. You must also specify the `swapFeeRecipient` and `swapFeeToken` in the request to use this feature. For security, this field has a default limit of 1000 Bps. If your application requires a higher value, please reach out to us.
         */
        swapFeeBps?: number;
        /**
         * The wallet address to receive the specified trading fees. You must also specify the `swapFeeToken` and `swapFeeBps` in the request to use this feature. Learn more about setting up a trading fee/commission in the FAQs
         */
        swapFeeRecipient?: string;
        /**
         * The contract address of the token to receive trading fees in. This must be set to the value of either the `buyToken` or the `sellToken`. You must also specify the `swapFeeRecipient` and `swapFeeBps` in the request to use this feature
         */
        swapFeeToken?: string;
        /**
         * The address which holds the `sellToken` balance and has the allowance set for the swap
         */
        taker?: string;
        /**
         * The address to receive any trade surplus. If specified, this address will receive trade surplus when applicable. Otherwise, the `taker` will receive the surplus
         */
        tradeSurplusRecipient?: string;
        txOrigin?: string;
    };
};

export type SwapPermit2GetPriceResponse = {
    /**
     * The block number at which the liquidity sources were sampled to generate the quote. This indicates the freshness of the quote
     */
    blockNumber: unknown & string;
    /**
     * The amount of `buyToken` (in `buyToken` units) that will be bought in the swap
     */
    buyAmount: unknown & string;
    /**
     * The contract address of the token to buy in the swap
     */
    buyToken: string;
    /**
     * Fees to be deducted in this transaction. It contains the `integratorFee`, `zeroExFee` and `gasFee`
     */
    fees: {
        /**
         * The specified fee to charge and deliver to the `swapFeeRecipient`.
         */
        integratorFee: {
            /**
             * The amount of token charged as the integrator fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the integrator fee
             */
            token: string;
            type: 'volume';
        } | null;
        /**
         * The fee charged by 0x for the trade.
         */
        zeroExFee: {
            /**
             * The amount of token charged as the 0x fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the 0x fee
             */
            token: string;
            type: 'volume';
        } | null;
        /**
         * The gas fee to be used in submitting the transaction.
         */
        gasFee: {
            /**
             * The amount of token charged as the gas fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the gas fee
             */
            token: string;
            type: 'gas';
        } | null;
    };
    /**
     * The estimated gas limit that should be used to send the transaction to guarantee settlement
     */
    gas: (unknown & string) | null;
    /**
     * The gas price (in wei) that should be used to send the transaction. The transaction needs to be sent with this `gasPrice` for the transaction to be successful
     */
    gasPrice: unknown & string;
    /**
     * An object containing potential issues discovered during 0x validation that can prevent the swap from being executed successfully by the `taker`
     */
    issues: {
        /**
         * Details of allowances that the `taker` must set for in order to execute the swap successfully. Null if no allowance is required
         */
        allowance: {
            /**
             * The `taker`'s current allowance of the `spender`
             */
            actual: unknown & string;
            /**
             * The address to set the allowance on
             */
            spender: string;
        } | null;
        /**
         * Details of balance of the `sellToken` that the `taker` must hold. Null if the `taker` has sufficient balance
         */
        balance: {
            /**
             * The contract address of the `sellToken`
             */
            token: string;
            /**
             * The current balance of the `sellToken` in the `taker` address
             */
            actual: unknown & string;
            /**
             * The balance of the `sellToken` required for the swap to execute successfully
             */
            expected: unknown & string;
        } | null;
        /**
         * This is set to `true` when 0x cannot validate the transaction. This happens when the `taker` has an insufficient balance of the `sellToken` and 0x is unable to peform ehanced quote validation with the low balance. Note that this does not necessarily mean that the trade will revert
         */
        simulationIncomplete: boolean;
        /**
         * A list of invalid sources present in `excludedSources` request. See https://api.0x.org/sources?chainId= with the desired chain's ID for the list of valid sources
         */
        invalidSourcesPassed: Array<(string)>;
    };
    /**
     * This validates the availability of liquidity for the quote requested. The rest of the fields will only be returned if `true`
     */
    liquidityAvailable: boolean;
    /**
     * The price which must be met or else the entire transaction will revert. This price is influenced by the `slippageBps` parameter. On-chain sources may encounter price movements from quote to settlement
     */
    minBuyAmount: unknown & string;
    /**
     * The path of liquidity sources to be used in executing this swap
     */
    route: {
        /**
         * Details of each segment that 0x routes the swap through
         */
        fills: Array<{
            /**
             * The contract address of the input token
             */
            from: string;
            /**
             * The contract address of the output token
             */
            to: string;
            /**
             * The liquidity source used in the route
             */
            source: string;
            /**
             * The proportion of the trade to be filled by the `source`
             */
            proportionBps: unknown & string;
        }>;
        /**
         * Properties of the tokens involved in the swap
         */
        tokens: Array<{
            /**
             * The token address. This is the unique identifier of the token
             */
            address: string;
            /**
             * The token symbol. This is not guaranteed to be unique, as multiple tokens can have the same symbol
             */
            symbol: string;
        }>;
    };
    /**
     * The amount of `sellToken` (in `sellToken` units) that will be sold in this swap
     */
    sellAmount: unknown & string;
    /**
     * The contract address of the token to sell in the swap
     */
    sellToken: string;
    /**
     * Swap-related metadata for the buy and sell token in the swap
     */
    tokenMetadata: {
        /**
         * Swap-related metadata for the buy token
         */
        buyToken: {
            /**
             * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            buyTaxBps: (unknown & string) | null;
            /**
             * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            sellTaxBps: (unknown & string) | null;
        };
        /**
         * Swap-related metadata for the sell token
         */
        sellToken: {
            /**
             * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            buyTaxBps: (unknown & string) | null;
            /**
             * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            sellTaxBps: (unknown & string) | null;
        };
    };
    /**
     * The estimated total network cost of the swap. On chains where they is no L1 data cost, it is calculated as `gas` * `gasPrice. On chains where there is an L1 data cost, it is calculated as `gas` * `gasPrice + L1 data
     */
    totalNetworkFee: (unknown & string) | null;
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
} | {
    /**
     * This validates the availability of liquidity for the quote requested. No other fields will be returned if it is `false`
     */
    liquidityAvailable: boolean;
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
};

export type SwapPermit2GetPriceError = INPUT_INVALID | TOKEN_NOT_SUPPORTED | TAKER_NOT_AUTHORIZED_FOR_TRADE | BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE | SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE | INTERNAL_SERVER_ERROR | UNCATEGORIZED;

export type SwapPermit2GetQuoteData = {
    headers: {
        /**
         * Visit dashboard.0x.org to get your API Key
         */
        '0x-api-key': string;
    };
    query: {
        /**
         * The contract address of the token to buy
         */
        buyToken: string;
        /**
         * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
         */
        chainId: number;
        /**
         * Liquidity sources e.g. Uniswap_V3, SushiSwap, 0x_RFQ to exclude from the provided quote. See https://api.0x.org/sources?chainId=<chain_id> with the desired chain's ID for a full list of sources. Separate multiple sources with a comma
         */
        excludedSources?: string;
        /**
         * The target gas price (in wei) for the swap transaction. If not provided, the default value is based on the 0x gas price oracle
         */
        gasPrice?: string;
        /**
         * The amount of `sellToken` in `sellToken` base units to sell
         */
        sellAmount: string;
        /**
         * The contract address of the token to sell
         */
        sellToken: string;
        /**
         * The maximum acceptable slippage of the `buyToken` in Bps. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100Bps
         */
        slippageBps?: number;
        /**
         * The amount in Bps of the `swapFeeToken` to charge and deliver to the `swapFeeRecipient`. You must also specify the `swapFeeRecipient` and `swapFeeToken` in the request to use this feature. For security, this field has a default limit of 1000 Bps. If your application requires a higher value, please reach out to us.
         */
        swapFeeBps?: number;
        /**
         * The wallet address to receive the specified trading fees. You must also specify the `swapFeeToken` and `swapFeeBps` in the request to use this feature. Learn more about setting up a trading fee/commission in the FAQs
         */
        swapFeeRecipient?: string;
        /**
         * The contract address of the token to receive trading fees in. This must be set to the value of either the `buyToken` or the `sellToken`. You must also specify the `swapFeeRecipient` and `swapFeeBps` in the request to use this feature
         */
        swapFeeToken?: string;
        /**
         * The address which holds the `sellToken` balance and has the allowance set for the swap
         */
        taker: string;
        /**
         * The address to receive any trade surplus. If specified, this address will receive trade surplus when applicable. Otherwise, the `taker` will receive the surplus
         */
        tradeSurplusRecipient?: string;
        txOrigin?: string;
    };
};

export type SwapPermit2GetQuoteResponse = {
    /**
     * The block number at which the liquidity sources were sampled to generate the quote. This indicates the freshness of the quote
     */
    blockNumber: unknown & string;
    /**
     * The amount of `buyToken` (in `buyToken` units) that will be bought in the swap
     */
    buyAmount: unknown & string;
    /**
     * The contract address of the token to buy in the swap
     */
    buyToken: string;
    fees: {
        /**
         * The specified fee to charge and deliver to the `swapFeeRecipient`.
         */
        integratorFee: {
            /**
             * The amount of token charged as the integrator fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the integrator fee
             */
            token: string;
            type: 'volume';
        } | null;
        /**
         * The fee charged by 0x for the trade.
         */
        zeroExFee: {
            /**
             * The amount of token charged as the 0x fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the 0x fee
             */
            token: string;
            type: 'volume';
        } | null;
        /**
         * The gas fee to be used in submitting the transaction.
         */
        gasFee: {
            /**
             * The amount of token charged as the gas fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the gas fee
             */
            token: string;
            type: 'gas';
        } | null;
    };
    /**
     * An object containing potential issues discovered during 0x validation that can prevent the swap from being executed successfully by the `taker`
     */
    issues: {
        /**
         * Details of allowances that the `taker` must set for in order to execute the swap successfully. Null if no allowance is required
         */
        allowance: {
            /**
             * The `taker`'s current allowance of the `spender`
             */
            actual: unknown & string;
            /**
             * The address to set the allowance on
             */
            spender: string;
        } | null;
        /**
         * Details of balance of the `sellToken` that the `taker` must hold. Null if the `taker` has sufficient balance
         */
        balance: {
            /**
             * The contract address of the `sellToken`
             */
            token: string;
            /**
             * The current balance of the `sellToken` in the `taker` address
             */
            actual: unknown & string;
            /**
             * The balance of the `sellToken` required for the swap to execute successfully
             */
            expected: unknown & string;
        } | null;
        /**
         * This is set to `true` when 0x cannot validate the transaction. This happens when the `taker` has an insufficient balance of the `sellToken` and 0x is unable to peform ehanced quote validation with the low balance. Note that this does not necessarily mean that the trade will revert
         */
        simulationIncomplete: boolean;
        /**
         * A list of invalid sources present in `excludedSources` request. See https://api.0x.org/sources?chainId= with the desired chain's ID for the list of valid sources
         */
        invalidSourcesPassed: Array<(string)>;
    };
    /**
     * This validates the availability of liquidity for the quote requested. The rest of the fields will only be returned if `true`
     */
    liquidityAvailable: boolean;
    /**
     * The price which must be met or else the transaction will revert. This price is influenced by the `slippageBps` parameter. On-chain sources may encounter price movements from quote to settlement
     */
    minBuyAmount: unknown & string;
    /**
     * This is the approval object which contains the necessary fields to submit an approval for this transaction. Null if sell token is the native token or the transaction is a native token wrap / unwrap
     */
    permit2: {
        /**
         * `Permit2`
         */
        type: 'Permit2';
        /**
         * The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). If you compute the hash from eip712 field, it should match the value of this field
         */
        hash: string;
        /**
         * Necessary data for [EIP-712](https://eips.ethereum.org/EIPS/eip-712)
         */
        eip712: {
            types: {
                [key: string]: Array<{
                    name: string;
                    type: string;
                }>;
            };
            domain: {
                name?: string;
                version?: string;
                chainId?: number;
                verifyingContract?: string;
                salt?: string;
            };
            message: {
                [key: string]: (string | Array<(string)> | number | Array<(number)> | boolean | Array<(boolean)> | unknown | Array<unknown>);
            };
            primaryType: string;
        };
    } | null;
    /**
     * The path of liquidity sources to be used in executing this swap
     */
    route: {
        /**
         * Details of each segment that 0x routes the swap through
         */
        fills: Array<{
            /**
             * The contract address of the input token
             */
            from: string;
            /**
             * The contract address of the output token
             */
            to: string;
            /**
             * The liquidity source used in the route
             */
            source: string;
            /**
             * The proportion of the trade to be filled by the `source`
             */
            proportionBps: unknown & string;
        }>;
        /**
         * Properties of the tokens involved in the swap
         */
        tokens: Array<{
            /**
             * The token address. This is the unique identifier of the token
             */
            address: string;
            /**
             * The token symbol. This is not guaranteed to be unique, as multiple tokens can have the same symbol
             */
            symbol: string;
        }>;
    };
    /**
     * The amount of `sellToken` (in `sellToken` units) that will be sold in this swap
     */
    sellAmount: unknown & string;
    /**
     * The contract address of the token to sell in the swap
     */
    sellToken: string;
    /**
     * Swap-related metadata for the buy and sell token in the swap
     */
    tokenMetadata: {
        /**
         * Swap-related metadata for the buy token
         */
        buyToken: {
            /**
             * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            buyTaxBps: (unknown & string) | null;
            /**
             * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            sellTaxBps: (unknown & string) | null;
        };
        /**
         * Swap-related metadata for the sell token
         */
        sellToken: {
            /**
             * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            buyTaxBps: (unknown & string) | null;
            /**
             * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            sellTaxBps: (unknown & string) | null;
        };
    };
    /**
     * The estimated total network cost of the swap. On chains where they is no L1 data cost, it is calculated as `gas` * `gasPrice. On chains where there is an L1 data cost, it is calculated as `gas` * `gasPrice + L1 data
     */
    totalNetworkFee: (unknown & string) | null;
    /**
     * This object contains the details required to submit the transaction
     */
    transaction: {
        /**
         * The address of the target contract to send call `data` to
         */
        to: string;
        /**
         * The calldata containing transaction execution details to be sent to the `to` address
         */
        data: string;
        /**
         * The estimated gas limit that should be used to send the transaction to guarantee settlement
         */
        gas: (unknown & string) | null;
        /**
         * The gas price (in wei) that should be used to send the transaction
         */
        gasPrice: unknown & string;
        /**
         * The amount of ether (in wei) that should be sent with the transaction
         */
        value: unknown & string;
    };
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
} | {
    /**
     * This validates the availability of liquidity for the quote requested. No other fields will be returned if it is `false`
     */
    liquidityAvailable: boolean;
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
};

export type SwapPermit2GetQuoteError = INPUT_INVALID | TOKEN_NOT_SUPPORTED | TAKER_NOT_AUTHORIZED_FOR_TRADE | BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE | SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE | INTERNAL_SERVER_ERROR | UNCATEGORIZED;

export type SwapAllowanceHolderGetPriceData = {
    headers: {
        /**
         * Visit dashboard.0x.org to get your API Key
         */
        '0x-api-key': string;
    };
    query: {
        /**
         * The contract address of the token to buy
         */
        buyToken: string;
        /**
         * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
         */
        chainId: number;
        /**
         * Liquidity sources e.g. Uniswap_V3, SushiSwap, 0x_RFQ to exclude from the provided quote. See https://api.0x.org/sources?chainId=<chain_id> with the desired chain's ID for a full list of sources. Separate multiple sources with a comma
         */
        excludedSources?: string;
        /**
         * The target gas price (in wei) for the swap transaction. If not provided, the default value is based on the 0x gas price oracle
         */
        gasPrice?: string;
        /**
         * The amount of `sellToken` in `sellToken` base units to sell
         */
        sellAmount: string;
        /**
         * The contract address of the token to sell
         */
        sellToken: string;
        /**
         * The maximum acceptable slippage of the `buyToken` in Bps. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100Bps
         */
        slippageBps?: number;
        /**
         * The amount in Bps of the `swapFeeToken` to charge and deliver to the `swapFeeRecipient`. You must also specify the `swapFeeRecipient` and `swapFeeToken` in the request to use this feature. For security, this field has a default limit of 1000 Bps. If your application requires a higher value, please reach out to us.
         */
        swapFeeBps?: number;
        /**
         * The wallet address to receive the specified trading fees. You must also specify the `swapFeeToken` and `swapFeeBps` in the request to use this feature. Learn more about setting up a trading fee/commission in the FAQs
         */
        swapFeeRecipient?: string;
        /**
         * The contract address of the token to receive trading fees in. This must be set to the value of either the `buyToken` or the `sellToken`. You must also specify the `swapFeeRecipient` and `swapFeeBps` in the request to use this feature
         */
        swapFeeToken?: string;
        /**
         * The address which holds the `sellToken` balance and has the allowance set for the swap
         */
        taker?: string;
        /**
         * The address to receive any trade surplus. If specified, this address will receive trade surplus when applicable. Otherwise, the `taker` will receive the surplus
         */
        tradeSurplusRecipient?: string;
        txOrigin?: string;
    };
};

export type SwapAllowanceHolderGetPriceResponse = {
    /**
     * The block number at which the liquidity sources were sampled to generate the quote. This indicates the freshness of the quote
     */
    blockNumber: unknown & string;
    /**
     * The amount of `buyToken` (in `buyToken` units) that will be bought in the swap
     */
    buyAmount: unknown & string;
    /**
     * The contract address of the token to buy in the swap
     */
    buyToken: string;
    /**
     * Fees to be deducted in this transaction. It contains the `integratorFee`, `zeroExFee` and `gasFee`
     */
    fees: {
        /**
         * The specified fee to charge and deliver to the `swapFeeRecipient`.
         */
        integratorFee: {
            /**
             * The amount of token charged as the integrator fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the integrator fee
             */
            token: string;
            type: 'volume';
        } | null;
        /**
         * The fee charged by 0x for the trade.
         */
        zeroExFee: {
            /**
             * The amount of token charged as the 0x fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the 0x fee
             */
            token: string;
            type: 'volume';
        } | null;
        /**
         * The gas fee to be used in submitting the transaction.
         */
        gasFee: {
            /**
             * The amount of token charged as the gas fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the gas fee
             */
            token: string;
            type: 'gas';
        } | null;
    };
    /**
     * The estimated gas limit that should be used to send the transaction to guarantee settlement
     */
    gas: (unknown & string) | null;
    /**
     * The gas price (in wei) that should be used to send the transaction. The transaction needs to be sent with this `gasPrice` for the transaction to be successful
     */
    gasPrice: unknown & string;
    /**
     * An object containing potential issues discovered during 0x validation that can prevent the swap from being executed successfully by the `taker`
     */
    issues: {
        /**
         * Details of allowances that the `taker` must set for in order to execute the swap successfully. Null if no allowance is required
         */
        allowance: {
            /**
             * The `taker`'s current allowance of the `spender`
             */
            actual: unknown & string;
            /**
             * The address to set the allowance on
             */
            spender: string;
        } | null;
        /**
         * Details of balance of the `sellToken` that the `taker` must hold. Null if the `taker` has sufficient balance
         */
        balance: {
            /**
             * The contract address of the `sellToken`
             */
            token: string;
            /**
             * The current balance of the `sellToken` in the `taker` address
             */
            actual: unknown & string;
            /**
             * The balance of the `sellToken` required for the swap to execute successfully
             */
            expected: unknown & string;
        } | null;
        /**
         * This is set to `true` when 0x cannot validate the transaction. This happens when the `taker` has an insufficient balance of the `sellToken` and 0x is unable to peform ehanced quote validation with the low balance. Note that this does not necessarily mean that the trade will revert
         */
        simulationIncomplete: boolean;
        /**
         * A list of invalid sources present in `excludedSources` request. See https://api.0x.org/sources?chainId= with the desired chain's ID for the list of valid sources
         */
        invalidSourcesPassed: Array<(string)>;
    };
    /**
     * This validates the availability of liquidity for the quote requested. The rest of the fields will only be returned if `true`
     */
    liquidityAvailable: boolean;
    /**
     * The price which must be met or else the entire transaction will revert. This price is influenced by the `slippageBps` parameter. On-chain sources may encounter price movements from quote to settlement
     */
    minBuyAmount: unknown & string;
    /**
     * The path of liquidity sources to be used in executing this swap
     */
    route: {
        /**
         * Details of each segment that 0x routes the swap through
         */
        fills: Array<{
            /**
             * The contract address of the input token
             */
            from: string;
            /**
             * The contract address of the output token
             */
            to: string;
            /**
             * The liquidity source used in the route
             */
            source: string;
            /**
             * The proportion of the trade to be filled by the `source`
             */
            proportionBps: unknown & string;
        }>;
        /**
         * Properties of the tokens involved in the swap
         */
        tokens: Array<{
            /**
             * The token address. This is the unique identifier of the token
             */
            address: string;
            /**
             * The token symbol. This is not guaranteed to be unique, as multiple tokens can have the same symbol
             */
            symbol: string;
        }>;
    };
    /**
     * The amount of `sellToken` (in `sellToken` units) that will be sold in this swap
     */
    sellAmount: unknown & string;
    /**
     * The contract address of the token to sell in the swap
     */
    sellToken: string;
    /**
     * Swap-related metadata for the buy and sell token in the swap
     */
    tokenMetadata: {
        /**
         * Swap-related metadata for the buy token
         */
        buyToken: {
            /**
             * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            buyTaxBps: (unknown & string) | null;
            /**
             * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            sellTaxBps: (unknown & string) | null;
        };
        /**
         * Swap-related metadata for the sell token
         */
        sellToken: {
            /**
             * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            buyTaxBps: (unknown & string) | null;
            /**
             * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            sellTaxBps: (unknown & string) | null;
        };
    };
    /**
     * The estimated total network cost of the swap. On chains where they is no L1 data cost, it is calculated as `gas` * `gasPrice. On chains where there is an L1 data cost, it is calculated as `gas` * `gasPrice + L1 data
     */
    totalNetworkFee: (unknown & string) | null;
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
} | {
    /**
     * This validates the availability of liquidity for the quote requested. No other fields will be returned if it is `false`
     */
    liquidityAvailable: boolean;
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
};

export type SwapAllowanceHolderGetPriceError = INPUT_INVALID | TOKEN_NOT_SUPPORTED | TAKER_NOT_AUTHORIZED_FOR_TRADE | BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE | SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE | INTERNAL_SERVER_ERROR | UNCATEGORIZED;

export type SwapAllowanceHolderGetQuoteData = {
    headers: {
        /**
         * Visit dashboard.0x.org to get your API Key
         */
        '0x-api-key': string;
    };
    query: {
        /**
         * The contract address of the token to buy
         */
        buyToken: string;
        /**
         * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
         */
        chainId: number;
        /**
         * Liquidity sources e.g. Uniswap_V3, SushiSwap, 0x_RFQ to exclude from the provided quote. See https://api.0x.org/sources?chainId=<chain_id> with the desired chain's ID for a full list of sources. Separate multiple sources with a comma
         */
        excludedSources?: string;
        /**
         * The target gas price (in wei) for the swap transaction. If not provided, the default value is based on the 0x gas price oracle
         */
        gasPrice?: string;
        /**
         * The amount of `sellToken` in `sellToken` base units to sell
         */
        sellAmount: string;
        /**
         * The contract address of the token to sell
         */
        sellToken: string;
        /**
         * The maximum acceptable slippage of the `buyToken` in Bps. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100Bps
         */
        slippageBps?: number;
        /**
         * The amount in Bps of the `swapFeeToken` to charge and deliver to the `swapFeeRecipient`. You must also specify the `swapFeeRecipient` and `swapFeeToken` in the request to use this feature. For security, this field has a default limit of 1000 Bps. If your application requires a higher value, please reach out to us.
         */
        swapFeeBps?: number;
        /**
         * The wallet address to receive the specified trading fees. You must also specify the `swapFeeToken` and `swapFeeBps` in the request to use this feature. Learn more about setting up a trading fee/commission in the FAQs
         */
        swapFeeRecipient?: string;
        /**
         * The contract address of the token to receive trading fees in. This must be set to the value of either the `buyToken` or the `sellToken`. You must also specify the `swapFeeRecipient` and `swapFeeBps` in the request to use this feature
         */
        swapFeeToken?: string;
        /**
         * The address which holds the `sellToken` balance and has the allowance set for the swap
         */
        taker: string;
        /**
         * The address to receive any trade surplus. If specified, this address will receive trade surplus when applicable. Otherwise, the `taker` will receive the surplus
         */
        tradeSurplusRecipient?: string;
        txOrigin?: string;
    };
};

export type SwapAllowanceHolderGetQuoteResponse = {
    /**
     * The block number at which the liquidity sources were sampled to generate the quote. This indicates the freshness of the quote
     */
    blockNumber: unknown & string;
    /**
     * The amount of `buyToken` (in `buyToken` units) that will be bought in the swap
     */
    buyAmount: unknown & string;
    /**
     * The contract address of the token to buy in the swap
     */
    buyToken: string;
    fees: {
        /**
         * The specified fee to charge and deliver to the `swapFeeRecipient`.
         */
        integratorFee: {
            /**
             * The amount of token charged as the integrator fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the integrator fee
             */
            token: string;
            type: 'volume';
        } | null;
        /**
         * The fee charged by 0x for the trade.
         */
        zeroExFee: {
            /**
             * The amount of token charged as the 0x fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the 0x fee
             */
            token: string;
            type: 'volume';
        } | null;
        /**
         * The gas fee to be used in submitting the transaction.
         */
        gasFee: {
            /**
             * The amount of token charged as the gas fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the gas fee
             */
            token: string;
            type: 'gas';
        } | null;
    };
    /**
     * An object containing potential issues discovered during 0x validation that can prevent the swap from being executed successfully by the `taker`
     */
    issues: {
        /**
         * Details of allowances that the `taker` must set for in order to execute the swap successfully. Null if no allowance is required
         */
        allowance: {
            /**
             * The `taker`'s current allowance of the `spender`
             */
            actual: unknown & string;
            /**
             * The address to set the allowance on
             */
            spender: string;
        } | null;
        /**
         * Details of balance of the `sellToken` that the `taker` must hold. Null if the `taker` has sufficient balance
         */
        balance: {
            /**
             * The contract address of the `sellToken`
             */
            token: string;
            /**
             * The current balance of the `sellToken` in the `taker` address
             */
            actual: unknown & string;
            /**
             * The balance of the `sellToken` required for the swap to execute successfully
             */
            expected: unknown & string;
        } | null;
        /**
         * This is set to `true` when 0x cannot validate the transaction. This happens when the `taker` has an insufficient balance of the `sellToken` and 0x is unable to peform ehanced quote validation with the low balance. Note that this does not necessarily mean that the trade will revert
         */
        simulationIncomplete: boolean;
        /**
         * A list of invalid sources present in `excludedSources` request. See https://api.0x.org/sources?chainId= with the desired chain's ID for the list of valid sources
         */
        invalidSourcesPassed: Array<(string)>;
    };
    /**
     * This validates the availability of liquidity for the quote requested. The rest of the fields will only be returned if `true`
     */
    liquidityAvailable: boolean;
    /**
     * The price which must be met or else the transaction will revert. This price is influenced by the `slippageBps` parameter. On-chain sources may encounter price movements from quote to settlement
     */
    minBuyAmount: unknown & string;
    /**
     * The path of liquidity sources to be used in executing this swap
     */
    route: {
        /**
         * Details of each segment that 0x routes the swap through
         */
        fills: Array<{
            /**
             * The contract address of the input token
             */
            from: string;
            /**
             * The contract address of the output token
             */
            to: string;
            /**
             * The liquidity source used in the route
             */
            source: string;
            /**
             * The proportion of the trade to be filled by the `source`
             */
            proportionBps: unknown & string;
        }>;
        /**
         * Properties of the tokens involved in the swap
         */
        tokens: Array<{
            /**
             * The token address. This is the unique identifier of the token
             */
            address: string;
            /**
             * The token symbol. This is not guaranteed to be unique, as multiple tokens can have the same symbol
             */
            symbol: string;
        }>;
    };
    /**
     * The amount of `sellToken` (in `sellToken` units) that will be sold in this swap
     */
    sellAmount: unknown & string;
    /**
     * The contract address of the token to sell in the swap
     */
    sellToken: string;
    /**
     * Swap-related metadata for the buy and sell token in the swap
     */
    tokenMetadata: {
        /**
         * Swap-related metadata for the buy token
         */
        buyToken: {
            /**
             * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            buyTaxBps: (unknown & string) | null;
            /**
             * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            sellTaxBps: (unknown & string) | null;
        };
        /**
         * Swap-related metadata for the sell token
         */
        sellToken: {
            /**
             * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            buyTaxBps: (unknown & string) | null;
            /**
             * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            sellTaxBps: (unknown & string) | null;
        };
    };
    /**
     * The estimated total network cost of the swap. On chains where there is no L1 data cost, it is calculated as `gas` * `gasPrice. On chains where there is an L1 data cost, it is calculated as `gas` * `gasPrice + L1 data
     */
    totalNetworkFee: (unknown & string) | null;
    /**
     * This object contains the details required to submit the transaction
     */
    transaction: {
        /**
         * The address of the target contract to send call `data` to
         */
        to: string;
        /**
         * The calldata containing transaction execution details to be sent to the `to` address
         */
        data: string;
        /**
         * The estimated gas limit that should be used to send the transaction to guarantee settlement
         */
        gas: (unknown & string) | null;
        /**
         * The gas price (in wei) that should be used to send the transaction
         */
        gasPrice: unknown & string;
        /**
         * The amount of ether (in wei) that should be sent with the transaction
         */
        value: unknown & string;
    };
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
} | {
    /**
     * This validates the availability of liquidity for the quote requested. No other fields will be returned if it is `false`
     */
    liquidityAvailable: boolean;
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
};

export type SwapAllowanceHolderGetQuoteError = INPUT_INVALID | TOKEN_NOT_SUPPORTED | TAKER_NOT_AUTHORIZED_FOR_TRADE | BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE | SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE | INTERNAL_SERVER_ERROR | UNCATEGORIZED;

export type GaslessGetPriceData = {
    headers: {
        /**
         * Visit dashboard.0x.org to get your API Key
         */
        '0x-api-key': string;
    };
    query: {
        /**
         * The contract address of the token to buy
         */
        buyToken: string;
        /**
         * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
         */
        chainId: number;
        /**
         * Liquidity sources e.g. Uniswap_V3, SushiSwap, 0x_RFQ to exclude from the provided quote. See https://api.0x.org/sources?chainId=<chain_id> with the desired chain's ID for a full list of sources. Separate multiple sources with a comma
         */
        excludedSources?: string;
        /**
         * The amount of `sellToken` in `sellToken` base units to sell
         */
        sellAmount: string;
        /**
         * The contract address of the token to sell. Native token is not supported
         */
        sellToken: string;
        /**
         * The amount in Bps of the `swapFeeToken` to charge and deliver to the `swapFeeRecipient`. You must also specify the `swapFeeRecipient` and `swapFeeToken` in the request to use this feature. For security, this field has a default limit of 1000 Bps. If your application requires a higher value, please reach out to us.
         */
        swapFeeBps?: number;
        /**
         * The wallet address to receive the specified trading fees. You must also specify the `swapFeeToken` and `swapFeeBps` in the request to use this feature. Learn more about setting up a trading fee/commission in the FAQs
         */
        swapFeeRecipient?: string;
        /**
         * The contract address of the token to receive trading fees in. This must be set to the value of either the `buyToken` or the `sellToken`. You must also specify the `swapFeeRecipient` and `swapFeeBps` in the request to use this feature
         */
        swapFeeToken?: string;
        /**
         * The address which holds the `sellToken` balance and has the allowance set for the swap
         */
        taker?: string;
        /**
         * The address to receive any trade surplus. If specified, this address will receive trade surplus when applicable. Otherwise, the `taker` will receive the surplus
         */
        tradeSurplusRecipient?: string;
    };
};

export type GaslessGetPriceResponse = {
    /**
     * The block number at which the liquidity sources were sampled to generate the quote. This indicates the freshness of the quote
     */
    blockNumber: unknown & string;
    /**
     * The amount of `buyToken` (in `buyToken` units) that will be bought in the swap
     */
    buyAmount: unknown & string;
    /**
     * The contract address of the token to buy in the swap
     */
    buyToken: string;
    /**
     * Fees to be deducted in this transaction. It contains the `integratorFee`, `zeroExFee` and `gasFee`
     */
    fees: {
        /**
         * The specified fee to charge and deliver to the `swapFeeRecipient`.
         */
        integratorFee: {
            /**
             * The amount of token charged as the integrator fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the integrator fee
             */
            token: string;
            type: 'volume';
        } | null;
        /**
         * The fee charged by 0x for the trade.
         */
        zeroExFee: {
            /**
             * The amount of token charged as the 0x fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the 0x fee
             */
            token: string;
            type: 'volume';
        } | null;
        /**
         * The gas fee to be used in submitting the transaction.
         */
        gasFee: {
            /**
             * The amount of token charged as the gas fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the gas fee
             */
            token: string;
            type: 'gas';
        } | null;
    };
    /**
     * An object containing potential issues discovered during 0x validation that can prevent the swap from being executed successfully by the `taker`
     */
    issues: {
        /**
         * Details of allowances that the `taker` must set for in order to execute the swap successfully. Null if no allowance is required
         */
        allowance: {
            /**
             * The `taker`'s current allowance of the `spender`
             */
            actual: unknown & string;
            /**
             * The address to set the allowance on
             */
            spender: string;
        } | null;
        /**
         * Details of balance of the `sellToken` that the `taker` must hold. Null if the `taker` has sufficient balance
         */
        balance: {
            /**
             * The contract address of the `sellToken`
             */
            token: string;
            /**
             * The current balance of the `sellToken` in the `taker` address
             */
            actual: unknown & string;
            /**
             * The balance of the `sellToken` required for the swap to execute successfully
             */
            expected: unknown & string;
        } | null;
        /**
         * This is set to `true` when 0x cannot validate the transaction. This happens when the `taker` has an insufficient balance of the `sellToken` and 0x is unable to peform ehanced quote validation with the low balance. Note that this does not necessarily mean that the trade will revert
         */
        simulationIncomplete: boolean;
        /**
         * A list of invalid sources present in `excludedSources` request. See https://api.0x.org/sources?chainId= with the desired chain's ID for the list of valid sources
         */
        invalidSourcesPassed: Array<(string)>;
    };
    /**
     * This validates the availability of liquidity for the quote requested. The rest of the fields will only be returned if `true`
     */
    liquidityAvailable: boolean;
    /**
     * The price which must be met or else the entire transaction will revert. This price is influenced by the `slippageBps` parameter. On-chain sources may encounter price movements from quote to settlement
     */
    minBuyAmount: unknown & string;
    /**
     * The path of liquidity sources to be used in executing this swap
     */
    route: {
        /**
         * Details of each segment that 0x routes the swap through
         */
        fills: Array<{
            /**
             * The contract address of the input token
             */
            from: string;
            /**
             * The contract address of the output token
             */
            to: string;
            /**
             * The liquidity source used in the route
             */
            source: string;
            /**
             * The proportion of the trade to be filled by the `source`
             */
            proportionBps: unknown & string;
        }>;
        /**
         * Properties of the tokens involved in the swap
         */
        tokens: Array<{
            /**
             * The token address. This is the unique identifier of the token
             */
            address: string;
            /**
             * The token symbol. This is not guaranteed to be unique, as multiple tokens can have the same symbol
             */
            symbol: string;
        }>;
    };
    /**
     * The amount of `sellToken` (in `sellToken` units) that will be sold in this swap
     */
    sellAmount: unknown & string;
    /**
     * The contract address of the token to sell in the swap
     */
    sellToken: string;
    /**
     * The address of the target contract that the transaction will be submitted to
     */
    target: string;
    /**
     * Swap-related metadata for the buy and sell token in the swap
     */
    tokenMetadata: {
        /**
         * Swap-related metadata for the buy token
         */
        buyToken: {
            /**
             * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            buyTaxBps: (unknown & string) | null;
            /**
             * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            sellTaxBps: (unknown & string) | null;
        };
        /**
         * Swap-related metadata for the sell token
         */
        sellToken: {
            /**
             * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            buyTaxBps: (unknown & string) | null;
            /**
             * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            sellTaxBps: (unknown & string) | null;
        };
    };
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
} | {
    /**
     * This validates the availability of liquidity for the quote requested. No other fields will be returned if it is `false`
     */
    liquidityAvailable: boolean;
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
};

export type GaslessGetPriceError = INPUT_INVALID | SELL_AMOUNT_TOO_SMALL | TOKEN_NOT_SUPPORTED | TAKER_NOT_AUTHORIZED_FOR_TRADE | BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE | SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE | INTERNAL_SERVER_ERROR | UNCATEGORIZED;

export type GaslessGetQuoteData = {
    headers: {
        /**
         * Visit dashboard.0x.org to get your API Key
         */
        '0x-api-key': string;
    };
    query: {
        /**
         * The contract address of the token to buy
         */
        buyToken: string;
        /**
         * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
         */
        chainId: number;
        /**
         * Liquidity sources e.g. Uniswap_V3, SushiSwap, 0x_RFQ to exclude from the provided quote. See https://api.0x.org/sources?chainId=<chain_id> with the desired chain's ID for a full list of sources. Separate multiple sources with a comma
         */
        excludedSources?: string;
        /**
         * The amount of `sellToken` in `sellToken` base units to sell
         */
        sellAmount: string;
        /**
         * The contract address of the token to sell. Native token is not supported
         */
        sellToken: string;
        /**
         * The amount in Bps of the `swapFeeToken` to charge and deliver to the `swapFeeRecipient`. You must also specify the `swapFeeRecipient` and `swapFeeToken` in the request to use this feature. For security, this field has a default limit of 1000 Bps. If your application requires a higher value, please reach out to us.
         */
        swapFeeBps?: number;
        /**
         * The wallet address to receive the specified trading fees. You must also specify the `swapFeeToken` and `swapFeeBps` in the request to use this feature. Learn more about setting up a trading fee/commission in the FAQs
         */
        swapFeeRecipient?: string;
        /**
         * The contract address of the token to receive trading fees in. This must be set to the value of either the `buyToken` or the `sellToken`. You must also specify the `swapFeeRecipient` and `swapFeeBps` in the request to use this feature
         */
        swapFeeToken?: string;
        /**
         * The address which holds the `sellToken` balance and has the allowance set for the swap
         */
        taker: string;
        /**
         * The address to receive any trade surplus. If specified, this address will receive trade surplus when applicable. Otherwise, the `taker` will receive the surplus
         */
        tradeSurplusRecipient?: string;
    };
};

export type GaslessGetQuoteResponse = {
    /**
     * This is the approval object which contains the necessary information to process a gasless approval
     */
    approval: {
        type: 'executeMetaTransaction::approve' | 'permit' | 'daiPermit';
        /**
         * The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). If you compute the hash from eip712 field, it should match the value of this field
         */
        hash: string;
        /**
         * The necessary data for [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Please don't assume static shapes for `approval.eip712.types`, `approval.eip712.domain`, `approval.eip712.primaryType` and `approval.eip712.message` as they will change depending on the `type`
         */
        eip712: {
            types: {
                [key: string]: Array<{
                    name: string;
                    type: string;
                }>;
            };
            domain: {
                name?: string;
                version?: string;
                chainId?: number;
                verifyingContract?: string;
                salt?: string;
            };
            message: {
                [key: string]: (string | Array<(string)> | number | Array<(number)> | boolean | Array<(boolean)> | unknown | Array<unknown>);
            };
            primaryType: string;
        };
    } | null;
    /**
     * The block number at which the liquidity sources were sampled to generate the quote. This indicates the freshness of the quote.
     */
    blockNumber: unknown & string;
    /**
     * The amount of `buyToken` (in `buyToken` units) that will be bought in the swap
     */
    buyAmount: unknown & string;
    /**
     * The contract address of the token to buy in the swap
     */
    buyToken: string;
    fees: {
        /**
         * The specified fee to charge and deliver to the `swapFeeRecipient`.
         */
        integratorFee: {
            /**
             * The amount of token charged as the integrator fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the integrator fee
             */
            token: string;
            type: 'volume';
        } | null;
        /**
         * The fee charged by 0x for the trade.
         */
        zeroExFee: {
            /**
             * The amount of token charged as the 0x fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the 0x fee
             */
            token: string;
            type: 'volume';
        } | null;
        /**
         * The gas fee to be used in submitting the transaction.
         */
        gasFee: {
            /**
             * The amount of token charged as the gas fee
             */
            amount: unknown & string;
            /**
             * The address of the token charged as the gas fee
             */
            token: string;
            type: 'gas';
        } | null;
    };
    /**
     * An object containing potential issues discovered during 0x validation that can prevent the swap from being executed successfully by the `taker`
     */
    issues: {
        /**
         * Details of allowances that the `taker` must set for in order to execute the swap successfully. Null if no allowance is required
         */
        allowance: {
            /**
             * The `taker`'s current allowance of the `spender`
             */
            actual: unknown & string;
            /**
             * The address to set the allowance on
             */
            spender: string;
        } | null;
        /**
         * Details of balance of the `sellToken` that the `taker` must hold. Null if the `taker` has sufficient balance
         */
        balance: {
            /**
             * The contract address of the `sellToken`
             */
            token: string;
            /**
             * The current balance of the `sellToken` in the `taker` address
             */
            actual: unknown & string;
            /**
             * The balance of the `sellToken` required for the swap to execute successfully
             */
            expected: unknown & string;
        } | null;
        /**
         * This is set to `true` when 0x cannot validate the transaction. This happens when the `taker` has an insufficient balance of the `sellToken` and 0x is unable to peform ehanced quote validation with the low balance. Note that this does not necessarily mean that the trade will revert
         */
        simulationIncomplete: boolean;
        /**
         * A list of invalid sources present in `excludedSources` request. See https://api.0x.org/sources?chainId= with the desired chain's ID for the list of valid sources
         */
        invalidSourcesPassed: Array<(string)>;
    };
    /**
     * This validates the availability of liquidity for the quote requested. The rest of the fields will only be returned if `true`
     */
    liquidityAvailable: boolean;
    /**
     * The price which must be met or else the transaction will revert. This price is influenced by the `slippageBps` parameter. On-chain sources may encounter price movements from quote to settlement
     */
    minBuyAmount: unknown & string;
    /**
     * The path of liquidity sources to be used in executing this swap
     */
    route: {
        /**
         * Details of each segment that 0x routes the swap through
         */
        fills: Array<{
            /**
             * The contract address of the input token
             */
            from: string;
            /**
             * The contract address of the output token
             */
            to: string;
            /**
             * The liquidity source used in the route
             */
            source: string;
            /**
             * The proportion of the trade to be filled by the `source`
             */
            proportionBps: unknown & string;
        }>;
        /**
         * Properties of the tokens involved in the swap
         */
        tokens: Array<{
            /**
             * The token address. This is the unique identifier of the token
             */
            address: string;
            /**
             * The token symbol. This is not guaranteed to be unique, as multiple tokens can have the same symbol
             */
            symbol: string;
        }>;
    };
    /**
     * The amount of `sellToken` (in `sellToken` units) that will be sold in this swap
     */
    sellAmount: unknown & string;
    /**
     * The contract address of the token to sell in the swap
     */
    sellToken: string;
    /**
     * The address of the target contract that the transaction will be submitted to
     */
    target: string;
    /**
     * Swap-related metadata for the buy and sell token in the swap
     */
    tokenMetadata: {
        /**
         * Swap-related metadata for the buy token
         */
        buyToken: {
            /**
             * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            buyTaxBps: (unknown & string) | null;
            /**
             * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            sellTaxBps: (unknown & string) | null;
        };
        /**
         * Swap-related metadata for the sell token
         */
        sellToken: {
            /**
             * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            buyTaxBps: (unknown & string) | null;
            /**
             * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
             */
            sellTaxBps: (unknown & string) | null;
        };
    };
    /**
     * This is the trade object which contains the necessary information to process a gasless trade
     */
    trade: {
        /**
         * The transaction type determined by the trade route. This is currently just `settler_metatransaction` and could expand to more types in the future
         */
        type: 'settler_metatransaction';
        /**
         * The hash for the trade according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). If you compute the hash from eip712 field, it should match the value of this field
         */
        hash: string;
        /**
         * This is the necessary data for [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Please don't assume static shapes for `trade.eip712.types`, `trade.eip712.domain`, `trade.eip712.primaryType` and `trade.eip712.message` as they will change depending on the `type`
         */
        eip712: {
            types: {
                [key: string]: Array<{
                    name: string;
                    type: string;
                }>;
            };
            domain: {
                name?: string;
                version?: string;
                chainId?: number;
                verifyingContract?: string;
                salt?: string;
            };
            message: {
                [key: string]: (string | Array<(string)> | number | Array<(number)> | boolean | Array<(boolean)> | unknown | Array<unknown>);
            };
            primaryType: string;
        };
    };
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
} | {
    /**
     * This validates the availability of liquidity for the quote requested. No other fields will be returned if it is `false`
     */
    liquidityAvailable: boolean;
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
};

export type GaslessGetQuoteError = INPUT_INVALID | INSUFFICIENT_BALANCE | SELL_AMOUNT_TOO_SMALL | TOKEN_NOT_SUPPORTED | TAKER_NOT_AUTHORIZED_FOR_TRADE | BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE | SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE | INTERNAL_SERVER_ERROR | UNCATEGORIZED;

export type GaslessSubmitData = {
    body: {
        /**
         * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
         */
        chainId: number;
        /**
         * The gasless approval object from the quote endpoint including its signature
         */
        approval?: {
            /**
             * The `approval.type` from the quote endpoint
             */
            type: 'executeMetaTransaction::approve' | 'permit' | 'daiPermit';
            eip712: {
    types: {
        EIP712Domain: Array<{
            name: string;
            type: string;
        }>;
        Permit: Array<{
            name: string;
            type: string;
        }>;
    };
    domain: {
        name?: string;
        version?: string;
        chainId?: number;
        verifyingContract?: string;
        salt?: string;
    };
    message: {
        owner: string;
        spender: string;
        value: string;
        nonce: number;
        deadline: string;
    };
    primaryType: 'Permit';
} | {
    types: {
        EIP712Domain: Array<{
            name: string;
            type: string;
        }>;
        Permit: Array<{
            name: string;
            type: string;
        }>;
    };
    domain: {
        name?: string;
        version?: string;
        chainId?: number;
        verifyingContract?: string;
        salt?: string;
    };
    message: {
        holder: string;
        spender: string;
        nonce: number;
        expiry: string;
        allowed: boolean;
    };
    primaryType: 'Permit';
} | {
    types: {
        EIP712Domain: Array<{
            name: string;
            type: string;
        }>;
        MetaTransaction: Array<{
            name: string;
            type: string;
        }>;
    };
    domain: {
        name?: string;
        version?: string;
        chainId?: number;
        verifyingContract?: string;
        salt?: string;
    };
    message: {
        nonce: number;
        from: string;
        functionSignature: string;
    };
    primaryType: 'MetaTransaction';
};
            signature: {
                signatureType: number;
                v: number;
                r: string;
                s: string;
            };
        } | null;
        /**
         * The trade object from the quote endpoint including its signature
         */
        trade: {
            /**
             * The `trade.type` from the quote endpoint
             */
            type: 'settler_metatransaction';
            /**
             * The `trade.eip712` from the quote endpoint
             */
            eip712: {
                types: {
                    [key: string]: Array<{
                        name: string;
                        type: string;
                    }>;
                };
                primaryType: string;
                domain: {
                    name?: string;
                    version?: string;
                    chainId?: number;
                    verifyingContract?: string;
                    salt?: string;
                };
                message: {
                    permitted: {
                        token: string;
                        amount: string | number | unknown;
                    };
                    spender: string;
                    nonce: string | number | unknown;
                    deadline: string | number | unknown;
                    slippageAndActions: {
                        recipient: string;
                        buyToken: string;
                        minAmountOut: string | number | unknown;
                        actions: Array<(string)>;
                    };
                };
            };
            signature: {
                signatureType: number;
                v: number;
                r: string;
                s: string;
            };
        };
    };
    headers: {
        /**
         * Visit dashboard.0x.org to get your API Key
         */
        '0x-api-key': string;
    };
};

export type GaslessSubmitResponse = {
    /**
     * The hash for the trade according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712)
     */
    tradeHash: string;
    /**
     * The transaction type determined by the trade route. This is currently just `settler_metatransaction` and could expand to more types in the future
     */
    type: 'settler_metatransaction';
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
};

export type GaslessSubmitError = INPUT_INVALID | INSUFFICIENT_BALANCE_OR_ALLOWANCE | INVALID_SIGNATURE | INVALID_SIGNER | META_TRANSACTION_EXPIRY_TOO_SOON | META_TRANSACTION_INVALID | PENDING_TRADES_ALREADY_EXIST | INTERNAL_SERVER_ERROR | UNCATEGORIZED;

export type GaslessGetStatusData = {
    headers: {
        /**
         * Visit dashboard.0x.org to get your API Key
         */
        '0x-api-key': string;
    };
    path: {
        /**
         * The hash for the trade according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712)
         */
        tradeHash: string;
    };
    query: {
        /**
         * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
         */
        chainId: number;
    };
};

export type GaslessGetStatusResponse = {
    /**
     * Details of the gasless approval transaction
     */
    approvalTransactions?: Array<{
        /**
         * The onchain transaction hash
         */
        hash: string;
        /**
         * The timestamp when the transaction was submitted onchain
         */
        timestamp: number;
    }>;
    /**
     * `pending` means that the order has been queued on 0x. `submitted` means that it has been submitted onchain,`succeeded` means it has been included in a block and `confirmed` means it has at least 3 confirmations onchain
     */
    status: 'pending' | 'submitted' | 'succeeded' | 'confirmed';
    /**
     * Details of the gasless swap transaction. If the trade is `pending`, no transaction will be returned. If `submitted`, multiple transactions may be returned, but only one will be mined. If `successful` and `confirmed`, the mined transaction will be returned
     */
    transactions: Array<{
        /**
         * The onchain transaction hash
         */
        hash: string;
        /**
         * The timestamp when the transaction was submitted onchain
         */
        timestamp: number;
    }>;
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
} | {
    /**
     * Details of the gasless approval transaction
     */
    approvalTransactions?: Array<{
        /**
         * The onchain transaction hash
         */
        hash: string;
        /**
         * The timestamp when the transaction was submitted onchain
         */
        timestamp: number;
    }>;
    /**
     * This provides more context about why the transaction failed
     */
    reason: 'transaction_simulation_failed' | 'order_expired' | 'last_look_declined' | 'transaction_reverted' | 'market_maker_sigature_error' | 'invalid_balance' | 'internal_error';
    /**
     * `failed` means that the order failed to be submitted onchain
     */
    status: 'failed';
    /**
     * Details of the gasless swap transaction. If the trade status is `failed`, there may be 0 (if it failed before submission) to multiple transactions (if the transaction reverted)
     */
    transactions: Array<{
        /**
         * The onchain transaction hash
         */
        hash: string;
        /**
         * The timestamp when the transaction was submitted onchain
         */
        timestamp: number;
    }>;
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
};

export type GaslessGetStatusError = INPUT_INVALID | META_TRANSACTION_STATUS_NOT_FOUND | INTERNAL_SERVER_ERROR | UNCATEGORIZED;

export type GaslessGetGaslessApprovalTokensData = {
    headers: {
        /**
         * Visit dashboard.0x.org to get your API Key
         */
        '0x-api-key': string;
    };
    query: {
        /**
         * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
         */
        chainId: number;
    };
};

export type GaslessGetGaslessApprovalTokensResponse = {
    /**
     * The list of tokens that can be used for gasless approvals
     */
    tokens: Array<(string)>;
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
};

export type GaslessGetGaslessApprovalTokensError = INPUT_INVALID | INTERNAL_SERVER_ERROR | UNCATEGORIZED;

export type SourcesGetSourcesData = {
    headers: {
        /**
         * Visit dashboard.0x.org to get your API Key
         */
        '0x-api-key': string;
    };
    query: {
        /**
         * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
         */
        chainId: number;
    };
};

export type SourcesGetSourcesResponse = {
    /**
     * The array of liquidity sources aggregated by 0x for the requested chain
     */
    sources: Array<(string)>;
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string;
};

export type SourcesGetSourcesError = INPUT_INVALID | INTERNAL_SERVER_ERROR | UNCATEGORIZED;