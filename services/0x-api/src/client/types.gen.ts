// This file is auto-generated by @hey-api/openapi-ts

export type BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE = {
  name: 'BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
  }
}

export type name = 'BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE'

export type INPUT_INVALID = {
  name: 'INPUT_INVALID'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
    /**
     * The list of invalid inputs
     */
    details: Array<{
      /**
       * The input field name
       */
      field: string
      /**
       * The validation failure reason
       */
      reason: string
    }>
  }
}

export type name2 = 'INPUT_INVALID'

export type INSUFFICIENT_BALANCE = {
  name: 'INSUFFICIENT_BALANCE'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
    /**
     * The taker of the transaction
     */
    taker: string
    /**
     * The sell token
     */
    sellToken: string
    /**
     * The sell amount
     */
    sellAmount: unknown & string
    /**
     * The current balance of the taker for the sell token
     */
    balance: unknown & string
  }
}

export type name3 = 'INSUFFICIENT_BALANCE'

export type INSUFFICIENT_BALANCE_OR_ALLOWANCE = {
  name: 'INSUFFICIENT_BALANCE_OR_ALLOWANCE'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
    /**
     * The hash of the meta-transaction provided by the caller
     */
    metaTransactionHash: string
    /**
     * The intended signer of the meta-transaction
     */
    taker: string
    /**
     * The sell token
     */
    sellToken: string
    /**
     * The sell amount
     */
    sellAmount: unknown & string
    /**
     * The smaller value of the balance or the allowance of the taker
     */
    minBalanceOrAllowance: unknown & string
  }
}

export type name4 = 'INSUFFICIENT_BALANCE_OR_ALLOWANCE'

export type INTERNAL_SERVER_ERROR = {
  name: 'INTERNAL_SERVER_ERROR'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
  }
}

export type name5 = 'INTERNAL_SERVER_ERROR'

export type INVALID_SIGNATURE = {
  name: 'INVALID_SIGNATURE'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
    /**
     * The hash of the meta-transaction provided by the caller
     */
    metaTransactionHash: string
    /**
     * The intended signer of the meta-transaction
     */
    taker: string
  }
}

export type name6 = 'INVALID_SIGNATURE'

export type INVALID_SIGNER = {
  name: 'INVALID_SIGNER'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
    /**
     * The hash of the meta-transaction provided by the caller
     */
    metaTransactionHash: string
    /**
     * The intended signer of the meta-transaction
     */
    taker: string
    /**
     * The signer of the meta-transaction
     */
    signer: string
  }
}

export type name7 = 'INVALID_SIGNER'

export type META_TRANSACTION_EXPIRY_TOO_SOON = {
  name: 'META_TRANSACTION_EXPIRY_TOO_SOON'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
    /**
     * The hash of the meta-transaction provided by the caller
     */
    metaTransactionHash: string
    /**
     * The expiry of the meta-transaction provided by the caller in ms
     */
    expiry: unknown & string
  }
}

export type name8 = 'META_TRANSACTION_EXPIRY_TOO_SOON'

export type META_TRANSACTION_INVALID = {
  name: 'META_TRANSACTION_INVALID'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
    /**
     * The hash of the meta-transaction provided by the caller
     */
    metaTransactionHash: string
  }
}

export type name9 = 'META_TRANSACTION_INVALID'

export type META_TRANSACTION_STATUS_NOT_FOUND = {
  name: 'META_TRANSACTION_STATUS_NOT_FOUND'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
  }
}

export type name10 = 'META_TRANSACTION_STATUS_NOT_FOUND'

export type PENDING_TRADES_ALREADY_EXIST = {
  name: 'PENDING_TRADES_ALREADY_EXIST'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
    /**
     * The hash of the meta-transaction provided by the caller
     */
    metaTransactionHash: string
    /**
     * The list of pending meta-transaction hashes for the same taker and sell token
     */
    pendingMetaTransactionHashes: Array<string>
  }
}

export type name11 = 'PENDING_TRADES_ALREADY_EXIST'

export type SELL_AMOUNT_TOO_SMALL = {
  name: 'SELL_AMOUNT_TOO_SMALL'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
    /**
     * The minimum sell amount required for the trade to go through
     */
    minSellAmount: unknown & string
  }
}

export type name12 = 'SELL_AMOUNT_TOO_SMALL'

export type SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE = {
  name: 'SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
  }
}

export type name13 = 'SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE'

export type TAKER_NOT_AUTHORIZED_FOR_TRADE = {
  name: 'TAKER_NOT_AUTHORIZED_FOR_TRADE'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
  }
}

export type name14 = 'TAKER_NOT_AUTHORIZED_FOR_TRADE'

export type TOKEN_NOT_SUPPORTED = {
  name: 'TOKEN_NOT_SUPPORTED'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
  }
}

export type name15 = 'TOKEN_NOT_SUPPORTED'

export type UNCATEGORIZED = {
  name: 'UNCATEGORIZED'
  message: string
  data: {
    /**
     * The unique ZeroEx identifier of the request
     */
    zid: string
  }
}

export type name16 = 'UNCATEGORIZED'

export type SwapPermit2GetPriceData = {
  headers: {
    /**
     * Visit dashboard.0x.org to get your API Key
     */
    '0x-api-key': string
  }
  query: {
    /**
     * The contract address of the token to buy
     */
    buyToken: string
    /**
     * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
     */
    chainId: number
    /**
     * Liquidity sources e.g. Uniswap_V3, SushiSwap, 0x_RFQ to exclude from the provided quote. See https://api.0x.org/sources?chainId=<chain_id> with the desired chain's ID for a full list of sources. Separate multiple sources with a comma
     */
    excludedSources?: string
    /**
     * The target gas price (in wei) for the swap transaction. If not provided, the default value is based on the 0x gas price oracle
     */
    gasPrice?: string
    /**
     * The amount of `sellToken` in `sellToken` base units to sell
     */
    sellAmount: string
    /**
     * The contract address of the token to sell
     */
    sellToken: string
    /**
     * The maximum acceptable slippage of the `buyToken` in Bps. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100Bps
     */
    slippageBps?: number
    /**
     * The amount in Bps of the `swapFeeToken` to charge and deliver to the `swapFeeRecipient`. You must also specify the `swapFeeRecipient` and `swapFeeToken` in the request to use this feature. For security, this field has a default limit of 1000 Bps. If your application requires a higher value, please reach out to us.
     */
    swapFeeBps?: number
    /**
     * The wallet address to receive the specified trading fees. You must also specify the `swapFeeToken` and `swapFeeBps` in the request to use this feature. Learn more about setting up a trading fee/commission in the FAQs
     */
    swapFeeRecipient?: string
    /**
     * The contract address of the token to receive trading fees in. This must be set to the value of either the `buyToken` or the `sellToken`. You must also specify the `swapFeeRecipient` and `swapFeeBps` in the request to use this feature
     */
    swapFeeToken?: string
    /**
     * The address which holds the `sellToken` balance and has the allowance set for the swap
     */
    taker?: string
    /**
     * The address to receive any trade surplus. If specified, this address will receive trade surplus when applicable. Otherwise, the `taker` will receive the surplus
     */
    tradeSurplusRecipient?: string
    txOrigin?: string
  }
}

export type SwapPermit2GetPriceResponse =
  | {
      /**
       * The block number at which the liquidity sources were sampled to generate the quote. This indicates the freshness of the quote
       */
      blockNumber: unknown & string
      /**
       * The amount of `buyToken` (in `buyToken` units) that will be bought in the swap
       */
      buyAmount: unknown & string
      /**
       * The contract address of the token to buy in the swap
       */
      buyToken: string
      /**
       * Fees to be deducted in this transaction. It contains the `integratorFee`, `zeroExFee` and `gasFee`
       */
      fees: {
        /**
         * The specified fee to charge and deliver to the `swapFeeRecipient`.
         */
        integratorFee: {
          /**
           * The amount of token charged as the integrator fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the integrator fee
           */
          token: string
          type: 'volume'
        } | null
        /**
         * The fee charged by 0x for the trade.
         */
        zeroExFee: {
          /**
           * The amount of token charged as the 0x fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the 0x fee
           */
          token: string
          type: 'volume'
        } | null
        /**
         * The gas fee to be used in submitting the transaction.
         */
        gasFee: {
          /**
           * The amount of token charged as the gas fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the gas fee
           */
          token: string
          type: 'gas'
        } | null
      }
      /**
       * The estimated gas limit that should be used to send the transaction to guarantee settlement
       */
      gas: (unknown & string) | null
      /**
       * The gas price (in wei) that should be used to send the transaction. The transaction needs to be sent with this `gasPrice` for the transaction to be successful
       */
      gasPrice: unknown & string
      /**
       * An object containing potential issues discovered during 0x validation that can prevent the swap from being executed successfully by the `taker`
       */
      issues: {
        /**
         * Details of allowances that the `taker` must set for in order to execute the swap successfully. Null if no allowance is required
         */
        allowance: {
          /**
           * The `taker`'s current allowance of the `spender`
           */
          actual: unknown & string
          /**
           * The address to set the allowance on
           */
          spender: string
        } | null
        /**
         * Details of balance of the `sellToken` that the `taker` must hold. Null if the `taker` has sufficient balance
         */
        balance: {
          /**
           * The contract address of the `sellToken`
           */
          token: string
          /**
           * The current balance of the `sellToken` in the `taker` address
           */
          actual: unknown & string
          /**
           * The balance of the `sellToken` required for the swap to execute successfully
           */
          expected: unknown & string
        } | null
        /**
         * This is set to `true` when 0x cannot validate the transaction. This happens when the `taker` has an insufficient balance of the `sellToken` and 0x is unable to peform ehanced quote validation with the low balance. Note that this does not necessarily mean that the trade will revert
         */
        simulationIncomplete: boolean
        /**
         * A list of invalid sources present in `excludedSources` request. See https://api.0x.org/sources?chainId= with the desired chain's ID for the list of valid sources
         */
        invalidSourcesPassed: Array<string>
      }
      /**
       * This validates the availability of liquidity for the quote requested. The rest of the fields will only be returned if `true`
       */
      liquidityAvailable: boolean
      /**
       * The price which must be met or else the entire transaction will revert. This price is influenced by the `slippageBps` parameter. On-chain sources may encounter price movements from quote to settlement
       */
      minBuyAmount: unknown & string
      /**
       * The path of liquidity sources to be used in executing this swap
       */
      route: {
        /**
         * Details of each segment that 0x routes the swap through
         */
        fills: Array<{
          /**
           * The contract address of the input token
           */
          from: string
          /**
           * The contract address of the output token
           */
          to: string
          /**
           * The liquidity source used in the route
           */
          source: string
          /**
           * The proportion of the trade to be filled by the `source`
           */
          proportionBps: unknown & string
        }>
        /**
         * Properties of the tokens involved in the swap
         */
        tokens: Array<{
          /**
           * The token address. This is the unique identifier of the token
           */
          address: string
          /**
           * The token symbol. This is not guaranteed to be unique, as multiple tokens can have the same symbol
           */
          symbol: string
        }>
      }
      /**
       * The amount of `sellToken` (in `sellToken` units) that will be sold in this swap
       */
      sellAmount: unknown & string
      /**
       * The contract address of the token to sell in the swap
       */
      sellToken: string
      /**
       * Swap-related metadata for the buy and sell token in the swap
       */
      tokenMetadata: {
        /**
         * Swap-related metadata for the buy token
         */
        buyToken: {
          /**
           * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          buyTaxBps: (unknown & string) | null
          /**
           * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          sellTaxBps: (unknown & string) | null
        }
        /**
         * Swap-related metadata for the sell token
         */
        sellToken: {
          /**
           * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          buyTaxBps: (unknown & string) | null
          /**
           * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          sellTaxBps: (unknown & string) | null
        }
      }
      /**
       * The estimated total network cost of the swap. On chains where they is no L1 data cost, it is calculated as `gas` * `gasPrice. On chains where there is an L1 data cost, it is calculated as `gas` * `gasPrice + L1 data
       */
      totalNetworkFee: (unknown & string) | null
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }
  | {
      /**
       * This validates the availability of liquidity for the quote requested. No other fields will be returned if it is `false`
       */
      liquidityAvailable: boolean
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }

export type SwapPermit2GetPriceError =
  | INPUT_INVALID
  | TOKEN_NOT_SUPPORTED
  | TAKER_NOT_AUTHORIZED_FOR_TRADE
  | BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE
  | SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE
  | INTERNAL_SERVER_ERROR
  | UNCATEGORIZED

export type SwapPermit2GetQuoteData = {
  headers: {
    /**
     * Visit dashboard.0x.org to get your API Key
     */
    '0x-api-key': string
  }
  query: {
    /**
     * The contract address of the token to buy
     */
    buyToken: string
    /**
     * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
     */
    chainId: number
    /**
     * Liquidity sources e.g. Uniswap_V3, SushiSwap, 0x_RFQ to exclude from the provided quote. See https://api.0x.org/sources?chainId=<chain_id> with the desired chain's ID for a full list of sources. Separate multiple sources with a comma
     */
    excludedSources?: string
    /**
     * The target gas price (in wei) for the swap transaction. If not provided, the default value is based on the 0x gas price oracle
     */
    gasPrice?: string
    /**
     * The amount of `sellToken` in `sellToken` base units to sell
     */
    sellAmount: string
    /**
     * The contract address of the token to sell
     */
    sellToken: string
    /**
     * The maximum acceptable slippage of the `buyToken` in Bps. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100Bps
     */
    slippageBps?: number
    /**
     * The amount in Bps of the `swapFeeToken` to charge and deliver to the `swapFeeRecipient`. You must also specify the `swapFeeRecipient` and `swapFeeToken` in the request to use this feature. For security, this field has a default limit of 1000 Bps. If your application requires a higher value, please reach out to us.
     */
    swapFeeBps?: number
    /**
     * The wallet address to receive the specified trading fees. You must also specify the `swapFeeToken` and `swapFeeBps` in the request to use this feature. Learn more about setting up a trading fee/commission in the FAQs
     */
    swapFeeRecipient?: string
    /**
     * The contract address of the token to receive trading fees in. This must be set to the value of either the `buyToken` or the `sellToken`. You must also specify the `swapFeeRecipient` and `swapFeeBps` in the request to use this feature
     */
    swapFeeToken?: string
    /**
     * The address which holds the `sellToken` balance and has the allowance set for the swap
     */
    taker: string
    /**
     * The address to receive any trade surplus. If specified, this address will receive trade surplus when applicable. Otherwise, the `taker` will receive the surplus
     */
    tradeSurplusRecipient?: string
    txOrigin?: string
  }
}

export type SwapPermit2GetQuoteResponse =
  | {
      /**
       * The block number at which the liquidity sources were sampled to generate the quote. This indicates the freshness of the quote
       */
      blockNumber: unknown & string
      /**
       * The amount of `buyToken` (in `buyToken` units) that will be bought in the swap
       */
      buyAmount: unknown & string
      /**
       * The contract address of the token to buy in the swap
       */
      buyToken: string
      fees: {
        /**
         * The specified fee to charge and deliver to the `swapFeeRecipient`.
         */
        integratorFee: {
          /**
           * The amount of token charged as the integrator fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the integrator fee
           */
          token: string
          type: 'volume'
        } | null
        /**
         * The fee charged by 0x for the trade.
         */
        zeroExFee: {
          /**
           * The amount of token charged as the 0x fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the 0x fee
           */
          token: string
          type: 'volume'
        } | null
        /**
         * The gas fee to be used in submitting the transaction.
         */
        gasFee: {
          /**
           * The amount of token charged as the gas fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the gas fee
           */
          token: string
          type: 'gas'
        } | null
      }
      /**
       * An object containing potential issues discovered during 0x validation that can prevent the swap from being executed successfully by the `taker`
       */
      issues: {
        /**
         * Details of allowances that the `taker` must set for in order to execute the swap successfully. Null if no allowance is required
         */
        allowance: {
          /**
           * The `taker`'s current allowance of the `spender`
           */
          actual: unknown & string
          /**
           * The address to set the allowance on
           */
          spender: string
        } | null
        /**
         * Details of balance of the `sellToken` that the `taker` must hold. Null if the `taker` has sufficient balance
         */
        balance: {
          /**
           * The contract address of the `sellToken`
           */
          token: string
          /**
           * The current balance of the `sellToken` in the `taker` address
           */
          actual: unknown & string
          /**
           * The balance of the `sellToken` required for the swap to execute successfully
           */
          expected: unknown & string
        } | null
        /**
         * This is set to `true` when 0x cannot validate the transaction. This happens when the `taker` has an insufficient balance of the `sellToken` and 0x is unable to peform ehanced quote validation with the low balance. Note that this does not necessarily mean that the trade will revert
         */
        simulationIncomplete: boolean
        /**
         * A list of invalid sources present in `excludedSources` request. See https://api.0x.org/sources?chainId= with the desired chain's ID for the list of valid sources
         */
        invalidSourcesPassed: Array<string>
      }
      /**
       * This validates the availability of liquidity for the quote requested. The rest of the fields will only be returned if `true`
       */
      liquidityAvailable: boolean
      /**
       * The price which must be met or else the transaction will revert. This price is influenced by the `slippageBps` parameter. On-chain sources may encounter price movements from quote to settlement
       */
      minBuyAmount: unknown & string
      /**
       * This is the approval object which contains the necessary fields to submit an approval for this transaction. Null if sell token is the native token or the transaction is a native token wrap / unwrap
       */
      permit2: {
        /**
         * `Permit2`
         */
        type: 'Permit2'
        /**
         * The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). If you compute the hash from eip712 field, it should match the value of this field
         */
        hash: string
        /**
         * Necessary data for [EIP-712](https://eips.ethereum.org/EIPS/eip-712)
         */
        eip712: {
          types: {
            [key: string]: Array<{
              name: string
              type: string
            }>
          }
          domain: {
            name?: string
            version?: string
            chainId?: number
            verifyingContract?: string
            salt?: string
          }
          message: {
            [key: string]:
              | string
              | Array<string>
              | number
              | Array<number>
              | boolean
              | Array<boolean>
              | unknown
              | Array<unknown>
          }
          primaryType: string
        }
      } | null
      /**
       * The path of liquidity sources to be used in executing this swap
       */
      route: {
        /**
         * Details of each segment that 0x routes the swap through
         */
        fills: Array<{
          /**
           * The contract address of the input token
           */
          from: string
          /**
           * The contract address of the output token
           */
          to: string
          /**
           * The liquidity source used in the route
           */
          source: string
          /**
           * The proportion of the trade to be filled by the `source`
           */
          proportionBps: unknown & string
        }>
        /**
         * Properties of the tokens involved in the swap
         */
        tokens: Array<{
          /**
           * The token address. This is the unique identifier of the token
           */
          address: string
          /**
           * The token symbol. This is not guaranteed to be unique, as multiple tokens can have the same symbol
           */
          symbol: string
        }>
      }
      /**
       * The amount of `sellToken` (in `sellToken` units) that will be sold in this swap
       */
      sellAmount: unknown & string
      /**
       * The contract address of the token to sell in the swap
       */
      sellToken: string
      /**
       * Swap-related metadata for the buy and sell token in the swap
       */
      tokenMetadata: {
        /**
         * Swap-related metadata for the buy token
         */
        buyToken: {
          /**
           * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          buyTaxBps: (unknown & string) | null
          /**
           * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          sellTaxBps: (unknown & string) | null
        }
        /**
         * Swap-related metadata for the sell token
         */
        sellToken: {
          /**
           * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          buyTaxBps: (unknown & string) | null
          /**
           * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          sellTaxBps: (unknown & string) | null
        }
      }
      /**
       * The estimated total network cost of the swap. On chains where they is no L1 data cost, it is calculated as `gas` * `gasPrice. On chains where there is an L1 data cost, it is calculated as `gas` * `gasPrice + L1 data
       */
      totalNetworkFee: (unknown & string) | null
      /**
       * This object contains the details required to submit the transaction
       */
      transaction: {
        /**
         * The address of the target contract to send call `data` to
         */
        to: string
        /**
         * The calldata containing transaction execution details to be sent to the `to` address
         */
        data: string
        /**
         * The estimated gas limit that should be used to send the transaction to guarantee settlement
         */
        gas: (unknown & string) | null
        /**
         * The gas price (in wei) that should be used to send the transaction
         */
        gasPrice: unknown & string
        /**
         * The amount of ether (in wei) that should be sent with the transaction
         */
        value: unknown & string
      }
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }
  | {
      /**
       * This validates the availability of liquidity for the quote requested. No other fields will be returned if it is `false`
       */
      liquidityAvailable: boolean
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }

export type SwapPermit2GetQuoteError =
  | INPUT_INVALID
  | TOKEN_NOT_SUPPORTED
  | TAKER_NOT_AUTHORIZED_FOR_TRADE
  | BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE
  | SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE
  | INTERNAL_SERVER_ERROR
  | UNCATEGORIZED

export type SwapAllowanceHolderGetPriceData = {
  headers: {
    /**
     * Visit dashboard.0x.org to get your API Key
     */
    '0x-api-key': string
  }
  query: {
    /**
     * The contract address of the token to buy
     */
    buyToken: string
    /**
     * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
     */
    chainId: number
    /**
     * Liquidity sources e.g. Uniswap_V3, SushiSwap, 0x_RFQ to exclude from the provided quote. See https://api.0x.org/sources?chainId=<chain_id> with the desired chain's ID for a full list of sources. Separate multiple sources with a comma
     */
    excludedSources?: string
    /**
     * The target gas price (in wei) for the swap transaction. If not provided, the default value is based on the 0x gas price oracle
     */
    gasPrice?: string
    /**
     * The amount of `sellToken` in `sellToken` base units to sell
     */
    sellAmount: string
    /**
     * The contract address of the token to sell
     */
    sellToken: string
    /**
     * The maximum acceptable slippage of the `buyToken` in Bps. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100Bps
     */
    slippageBps?: number
    /**
     * The amount in Bps of the `swapFeeToken` to charge and deliver to the `swapFeeRecipient`. You must also specify the `swapFeeRecipient` and `swapFeeToken` in the request to use this feature. For security, this field has a default limit of 1000 Bps. If your application requires a higher value, please reach out to us.
     */
    swapFeeBps?: number
    /**
     * The wallet address to receive the specified trading fees. You must also specify the `swapFeeToken` and `swapFeeBps` in the request to use this feature. Learn more about setting up a trading fee/commission in the FAQs
     */
    swapFeeRecipient?: string
    /**
     * The contract address of the token to receive trading fees in. This must be set to the value of either the `buyToken` or the `sellToken`. You must also specify the `swapFeeRecipient` and `swapFeeBps` in the request to use this feature
     */
    swapFeeToken?: string
    /**
     * The address which holds the `sellToken` balance and has the allowance set for the swap
     */
    taker?: string
    /**
     * The address to receive any trade surplus. If specified, this address will receive trade surplus when applicable. Otherwise, the `taker` will receive the surplus
     */
    tradeSurplusRecipient?: string
    txOrigin?: string
  }
}

export type SwapAllowanceHolderGetPriceResponse =
  | {
      /**
       * The block number at which the liquidity sources were sampled to generate the quote. This indicates the freshness of the quote
       */
      blockNumber: unknown & string
      /**
       * The amount of `buyToken` (in `buyToken` units) that will be bought in the swap
       */
      buyAmount: unknown & string
      /**
       * The contract address of the token to buy in the swap
       */
      buyToken: string
      /**
       * Fees to be deducted in this transaction. It contains the `integratorFee`, `zeroExFee` and `gasFee`
       */
      fees: {
        /**
         * The specified fee to charge and deliver to the `swapFeeRecipient`.
         */
        integratorFee: {
          /**
           * The amount of token charged as the integrator fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the integrator fee
           */
          token: string
          type: 'volume'
        } | null
        /**
         * The fee charged by 0x for the trade.
         */
        zeroExFee: {
          /**
           * The amount of token charged as the 0x fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the 0x fee
           */
          token: string
          type: 'volume'
        } | null
        /**
         * The gas fee to be used in submitting the transaction.
         */
        gasFee: {
          /**
           * The amount of token charged as the gas fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the gas fee
           */
          token: string
          type: 'gas'
        } | null
      }
      /**
       * The estimated gas limit that should be used to send the transaction to guarantee settlement
       */
      gas: (unknown & string) | null
      /**
       * The gas price (in wei) that should be used to send the transaction. The transaction needs to be sent with this `gasPrice` for the transaction to be successful
       */
      gasPrice: unknown & string
      /**
       * An object containing potential issues discovered during 0x validation that can prevent the swap from being executed successfully by the `taker`
       */
      issues: {
        /**
         * Details of allowances that the `taker` must set for in order to execute the swap successfully. Null if no allowance is required
         */
        allowance: {
          /**
           * The `taker`'s current allowance of the `spender`
           */
          actual: unknown & string
          /**
           * The address to set the allowance on
           */
          spender: string
        } | null
        /**
         * Details of balance of the `sellToken` that the `taker` must hold. Null if the `taker` has sufficient balance
         */
        balance: {
          /**
           * The contract address of the `sellToken`
           */
          token: string
          /**
           * The current balance of the `sellToken` in the `taker` address
           */
          actual: unknown & string
          /**
           * The balance of the `sellToken` required for the swap to execute successfully
           */
          expected: unknown & string
        } | null
        /**
         * This is set to `true` when 0x cannot validate the transaction. This happens when the `taker` has an insufficient balance of the `sellToken` and 0x is unable to peform ehanced quote validation with the low balance. Note that this does not necessarily mean that the trade will revert
         */
        simulationIncomplete: boolean
        /**
         * A list of invalid sources present in `excludedSources` request. See https://api.0x.org/sources?chainId= with the desired chain's ID for the list of valid sources
         */
        invalidSourcesPassed: Array<string>
      }
      /**
       * This validates the availability of liquidity for the quote requested. The rest of the fields will only be returned if `true`
       */
      liquidityAvailable: boolean
      /**
       * The price which must be met or else the entire transaction will revert. This price is influenced by the `slippageBps` parameter. On-chain sources may encounter price movements from quote to settlement
       */
      minBuyAmount: unknown & string
      /**
       * The path of liquidity sources to be used in executing this swap
       */
      route: {
        /**
         * Details of each segment that 0x routes the swap through
         */
        fills: Array<{
          /**
           * The contract address of the input token
           */
          from: string
          /**
           * The contract address of the output token
           */
          to: string
          /**
           * The liquidity source used in the route
           */
          source: string
          /**
           * The proportion of the trade to be filled by the `source`
           */
          proportionBps: unknown & string
        }>
        /**
         * Properties of the tokens involved in the swap
         */
        tokens: Array<{
          /**
           * The token address. This is the unique identifier of the token
           */
          address: string
          /**
           * The token symbol. This is not guaranteed to be unique, as multiple tokens can have the same symbol
           */
          symbol: string
        }>
      }
      /**
       * The amount of `sellToken` (in `sellToken` units) that will be sold in this swap
       */
      sellAmount: unknown & string
      /**
       * The contract address of the token to sell in the swap
       */
      sellToken: string
      /**
       * Swap-related metadata for the buy and sell token in the swap
       */
      tokenMetadata: {
        /**
         * Swap-related metadata for the buy token
         */
        buyToken: {
          /**
           * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          buyTaxBps: (unknown & string) | null
          /**
           * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          sellTaxBps: (unknown & string) | null
        }
        /**
         * Swap-related metadata for the sell token
         */
        sellToken: {
          /**
           * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          buyTaxBps: (unknown & string) | null
          /**
           * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          sellTaxBps: (unknown & string) | null
        }
      }
      /**
       * The estimated total network cost of the swap. On chains where they is no L1 data cost, it is calculated as `gas` * `gasPrice. On chains where there is an L1 data cost, it is calculated as `gas` * `gasPrice + L1 data
       */
      totalNetworkFee: (unknown & string) | null
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }
  | {
      /**
       * This validates the availability of liquidity for the quote requested. No other fields will be returned if it is `false`
       */
      liquidityAvailable: boolean
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }

export type SwapAllowanceHolderGetPriceError =
  | INPUT_INVALID
  | TOKEN_NOT_SUPPORTED
  | TAKER_NOT_AUTHORIZED_FOR_TRADE
  | BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE
  | SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE
  | INTERNAL_SERVER_ERROR
  | UNCATEGORIZED

export type SwapAllowanceHolderGetQuoteData = {
  headers: {
    /**
     * Visit dashboard.0x.org to get your API Key
     */
    '0x-api-key': string
  }
  query: {
    /**
     * The contract address of the token to buy
     */
    buyToken: string
    /**
     * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
     */
    chainId: number
    /**
     * Liquidity sources e.g. Uniswap_V3, SushiSwap, 0x_RFQ to exclude from the provided quote. See https://api.0x.org/sources?chainId=<chain_id> with the desired chain's ID for a full list of sources. Separate multiple sources with a comma
     */
    excludedSources?: string
    /**
     * The target gas price (in wei) for the swap transaction. If not provided, the default value is based on the 0x gas price oracle
     */
    gasPrice?: string
    /**
     * The amount of `sellToken` in `sellToken` base units to sell
     */
    sellAmount: string
    /**
     * The contract address of the token to sell
     */
    sellToken: string
    /**
     * The maximum acceptable slippage of the `buyToken` in Bps. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100Bps
     */
    slippageBps?: number
    /**
     * The amount in Bps of the `swapFeeToken` to charge and deliver to the `swapFeeRecipient`. You must also specify the `swapFeeRecipient` and `swapFeeToken` in the request to use this feature. For security, this field has a default limit of 1000 Bps. If your application requires a higher value, please reach out to us.
     */
    swapFeeBps?: number
    /**
     * The wallet address to receive the specified trading fees. You must also specify the `swapFeeToken` and `swapFeeBps` in the request to use this feature. Learn more about setting up a trading fee/commission in the FAQs
     */
    swapFeeRecipient?: string
    /**
     * The contract address of the token to receive trading fees in. This must be set to the value of either the `buyToken` or the `sellToken`. You must also specify the `swapFeeRecipient` and `swapFeeBps` in the request to use this feature
     */
    swapFeeToken?: string
    /**
     * The address which holds the `sellToken` balance and has the allowance set for the swap
     */
    taker: string
    /**
     * The address to receive any trade surplus. If specified, this address will receive trade surplus when applicable. Otherwise, the `taker` will receive the surplus
     */
    tradeSurplusRecipient?: string
    txOrigin?: string
  }
}

export type SwapAllowanceHolderGetQuoteResponse =
  | {
      /**
       * The block number at which the liquidity sources were sampled to generate the quote. This indicates the freshness of the quote
       */
      blockNumber: unknown & string
      /**
       * The amount of `buyToken` (in `buyToken` units) that will be bought in the swap
       */
      buyAmount: unknown & string
      /**
       * The contract address of the token to buy in the swap
       */
      buyToken: string
      fees: {
        /**
         * The specified fee to charge and deliver to the `swapFeeRecipient`.
         */
        integratorFee: {
          /**
           * The amount of token charged as the integrator fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the integrator fee
           */
          token: string
          type: 'volume'
        } | null
        /**
         * The fee charged by 0x for the trade.
         */
        zeroExFee: {
          /**
           * The amount of token charged as the 0x fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the 0x fee
           */
          token: string
          type: 'volume'
        } | null
        /**
         * The gas fee to be used in submitting the transaction.
         */
        gasFee: {
          /**
           * The amount of token charged as the gas fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the gas fee
           */
          token: string
          type: 'gas'
        } | null
      }
      /**
       * An object containing potential issues discovered during 0x validation that can prevent the swap from being executed successfully by the `taker`
       */
      issues: {
        /**
         * Details of allowances that the `taker` must set for in order to execute the swap successfully. Null if no allowance is required
         */
        allowance: {
          /**
           * The `taker`'s current allowance of the `spender`
           */
          actual: unknown & string
          /**
           * The address to set the allowance on
           */
          spender: string
        } | null
        /**
         * Details of balance of the `sellToken` that the `taker` must hold. Null if the `taker` has sufficient balance
         */
        balance: {
          /**
           * The contract address of the `sellToken`
           */
          token: string
          /**
           * The current balance of the `sellToken` in the `taker` address
           */
          actual: unknown & string
          /**
           * The balance of the `sellToken` required for the swap to execute successfully
           */
          expected: unknown & string
        } | null
        /**
         * This is set to `true` when 0x cannot validate the transaction. This happens when the `taker` has an insufficient balance of the `sellToken` and 0x is unable to peform ehanced quote validation with the low balance. Note that this does not necessarily mean that the trade will revert
         */
        simulationIncomplete: boolean
        /**
         * A list of invalid sources present in `excludedSources` request. See https://api.0x.org/sources?chainId= with the desired chain's ID for the list of valid sources
         */
        invalidSourcesPassed: Array<string>
      }
      /**
       * This validates the availability of liquidity for the quote requested. The rest of the fields will only be returned if `true`
       */
      liquidityAvailable: boolean
      /**
       * The price which must be met or else the transaction will revert. This price is influenced by the `slippageBps` parameter. On-chain sources may encounter price movements from quote to settlement
       */
      minBuyAmount: unknown & string
      /**
       * The path of liquidity sources to be used in executing this swap
       */
      route: {
        /**
         * Details of each segment that 0x routes the swap through
         */
        fills: Array<{
          /**
           * The contract address of the input token
           */
          from: string
          /**
           * The contract address of the output token
           */
          to: string
          /**
           * The liquidity source used in the route
           */
          source: string
          /**
           * The proportion of the trade to be filled by the `source`
           */
          proportionBps: unknown & string
        }>
        /**
         * Properties of the tokens involved in the swap
         */
        tokens: Array<{
          /**
           * The token address. This is the unique identifier of the token
           */
          address: string
          /**
           * The token symbol. This is not guaranteed to be unique, as multiple tokens can have the same symbol
           */
          symbol: string
        }>
      }
      /**
       * The amount of `sellToken` (in `sellToken` units) that will be sold in this swap
       */
      sellAmount: unknown & string
      /**
       * The contract address of the token to sell in the swap
       */
      sellToken: string
      /**
       * Swap-related metadata for the buy and sell token in the swap
       */
      tokenMetadata: {
        /**
         * Swap-related metadata for the buy token
         */
        buyToken: {
          /**
           * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          buyTaxBps: (unknown & string) | null
          /**
           * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          sellTaxBps: (unknown & string) | null
        }
        /**
         * Swap-related metadata for the sell token
         */
        sellToken: {
          /**
           * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          buyTaxBps: (unknown & string) | null
          /**
           * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          sellTaxBps: (unknown & string) | null
        }
      }
      /**
       * The estimated total network cost of the swap. On chains where there is no L1 data cost, it is calculated as `gas` * `gasPrice. On chains where there is an L1 data cost, it is calculated as `gas` * `gasPrice + L1 data
       */
      totalNetworkFee: (unknown & string) | null
      /**
       * This object contains the details required to submit the transaction
       */
      transaction: {
        /**
         * The address of the target contract to send call `data` to
         */
        to: string
        /**
         * The calldata containing transaction execution details to be sent to the `to` address
         */
        data: string
        /**
         * The estimated gas limit that should be used to send the transaction to guarantee settlement
         */
        gas: (unknown & string) | null
        /**
         * The gas price (in wei) that should be used to send the transaction
         */
        gasPrice: unknown & string
        /**
         * The amount of ether (in wei) that should be sent with the transaction
         */
        value: unknown & string
      }
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }
  | {
      /**
       * This validates the availability of liquidity for the quote requested. No other fields will be returned if it is `false`
       */
      liquidityAvailable: boolean
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }

export type SwapAllowanceHolderGetQuoteError =
  | INPUT_INVALID
  | TOKEN_NOT_SUPPORTED
  | TAKER_NOT_AUTHORIZED_FOR_TRADE
  | BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE
  | SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE
  | INTERNAL_SERVER_ERROR
  | UNCATEGORIZED

export type GaslessGetPriceData = {
  headers: {
    /**
     * Visit dashboard.0x.org to get your API Key
     */
    '0x-api-key': string
  }
  query: {
    /**
     * The contract address of the token to buy
     */
    buyToken: string
    /**
     * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
     */
    chainId: number
    /**
     * Liquidity sources e.g. Uniswap_V3, SushiSwap, 0x_RFQ to exclude from the provided quote. See https://api.0x.org/sources?chainId=<chain_id> with the desired chain's ID for a full list of sources. Separate multiple sources with a comma
     */
    excludedSources?: string
    /**
     * The amount of `sellToken` in `sellToken` base units to sell
     */
    sellAmount: string
    /**
     * The contract address of the token to sell. Native token is not supported
     */
    sellToken: string
    /**
     * The amount in Bps of the `swapFeeToken` to charge and deliver to the `swapFeeRecipient`. You must also specify the `swapFeeRecipient` and `swapFeeToken` in the request to use this feature. For security, this field has a default limit of 1000 Bps. If your application requires a higher value, please reach out to us.
     */
    swapFeeBps?: number
    /**
     * The wallet address to receive the specified trading fees. You must also specify the `swapFeeToken` and `swapFeeBps` in the request to use this feature. Learn more about setting up a trading fee/commission in the FAQs
     */
    swapFeeRecipient?: string
    /**
     * The contract address of the token to receive trading fees in. This must be set to the value of either the `buyToken` or the `sellToken`. You must also specify the `swapFeeRecipient` and `swapFeeBps` in the request to use this feature
     */
    swapFeeToken?: string
    /**
     * The address which holds the `sellToken` balance and has the allowance set for the swap
     */
    taker?: string
    /**
     * The address to receive any trade surplus. If specified, this address will receive trade surplus when applicable. Otherwise, the `taker` will receive the surplus
     */
    tradeSurplusRecipient?: string
  }
}

export type GaslessGetPriceResponse =
  | {
      /**
       * The block number at which the liquidity sources were sampled to generate the quote. This indicates the freshness of the quote
       */
      blockNumber: unknown & string
      /**
       * The amount of `buyToken` (in `buyToken` units) that will be bought in the swap
       */
      buyAmount: unknown & string
      /**
       * The contract address of the token to buy in the swap
       */
      buyToken: string
      /**
       * Fees to be deducted in this transaction. It contains the `integratorFee`, `zeroExFee` and `gasFee`
       */
      fees: {
        /**
         * The specified fee to charge and deliver to the `swapFeeRecipient`.
         */
        integratorFee: {
          /**
           * The amount of token charged as the integrator fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the integrator fee
           */
          token: string
          type: 'volume'
        } | null
        /**
         * The fee charged by 0x for the trade.
         */
        zeroExFee: {
          /**
           * The amount of token charged as the 0x fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the 0x fee
           */
          token: string
          type: 'volume'
        } | null
        /**
         * The gas fee to be used in submitting the transaction.
         */
        gasFee: {
          /**
           * The amount of token charged as the gas fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the gas fee
           */
          token: string
          type: 'gas'
        } | null
      }
      /**
       * An object containing potential issues discovered during 0x validation that can prevent the swap from being executed successfully by the `taker`
       */
      issues: {
        /**
         * Details of allowances that the `taker` must set for in order to execute the swap successfully. Null if no allowance is required
         */
        allowance: {
          /**
           * The `taker`'s current allowance of the `spender`
           */
          actual: unknown & string
          /**
           * The address to set the allowance on
           */
          spender: string
        } | null
        /**
         * Details of balance of the `sellToken` that the `taker` must hold. Null if the `taker` has sufficient balance
         */
        balance: {
          /**
           * The contract address of the `sellToken`
           */
          token: string
          /**
           * The current balance of the `sellToken` in the `taker` address
           */
          actual: unknown & string
          /**
           * The balance of the `sellToken` required for the swap to execute successfully
           */
          expected: unknown & string
        } | null
        /**
         * This is set to `true` when 0x cannot validate the transaction. This happens when the `taker` has an insufficient balance of the `sellToken` and 0x is unable to peform ehanced quote validation with the low balance. Note that this does not necessarily mean that the trade will revert
         */
        simulationIncomplete: boolean
        /**
         * A list of invalid sources present in `excludedSources` request. See https://api.0x.org/sources?chainId= with the desired chain's ID for the list of valid sources
         */
        invalidSourcesPassed: Array<string>
      }
      /**
       * This validates the availability of liquidity for the quote requested. The rest of the fields will only be returned if `true`
       */
      liquidityAvailable: boolean
      /**
       * The price which must be met or else the entire transaction will revert. This price is influenced by the `slippageBps` parameter. On-chain sources may encounter price movements from quote to settlement
       */
      minBuyAmount: unknown & string
      /**
       * The path of liquidity sources to be used in executing this swap
       */
      route: {
        /**
         * Details of each segment that 0x routes the swap through
         */
        fills: Array<{
          /**
           * The contract address of the input token
           */
          from: string
          /**
           * The contract address of the output token
           */
          to: string
          /**
           * The liquidity source used in the route
           */
          source: string
          /**
           * The proportion of the trade to be filled by the `source`
           */
          proportionBps: unknown & string
        }>
        /**
         * Properties of the tokens involved in the swap
         */
        tokens: Array<{
          /**
           * The token address. This is the unique identifier of the token
           */
          address: string
          /**
           * The token symbol. This is not guaranteed to be unique, as multiple tokens can have the same symbol
           */
          symbol: string
        }>
      }
      /**
       * The amount of `sellToken` (in `sellToken` units) that will be sold in this swap
       */
      sellAmount: unknown & string
      /**
       * The contract address of the token to sell in the swap
       */
      sellToken: string
      /**
       * The address of the target contract that the transaction will be submitted to
       */
      target: string
      /**
       * Swap-related metadata for the buy and sell token in the swap
       */
      tokenMetadata: {
        /**
         * Swap-related metadata for the buy token
         */
        buyToken: {
          /**
           * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          buyTaxBps: (unknown & string) | null
          /**
           * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          sellTaxBps: (unknown & string) | null
        }
        /**
         * Swap-related metadata for the sell token
         */
        sellToken: {
          /**
           * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          buyTaxBps: (unknown & string) | null
          /**
           * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          sellTaxBps: (unknown & string) | null
        }
      }
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }
  | {
      /**
       * This validates the availability of liquidity for the quote requested. No other fields will be returned if it is `false`
       */
      liquidityAvailable: boolean
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }

export type GaslessGetPriceError =
  | INPUT_INVALID
  | SELL_AMOUNT_TOO_SMALL
  | TOKEN_NOT_SUPPORTED
  | TAKER_NOT_AUTHORIZED_FOR_TRADE
  | BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE
  | SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE
  | INTERNAL_SERVER_ERROR
  | UNCATEGORIZED

export type GaslessGetQuoteData = {
  headers: {
    /**
     * Visit dashboard.0x.org to get your API Key
     */
    '0x-api-key': string
  }
  query: {
    /**
     * The contract address of the token to buy
     */
    buyToken: string
    /**
     * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
     */
    chainId: number
    /**
     * Liquidity sources e.g. Uniswap_V3, SushiSwap, 0x_RFQ to exclude from the provided quote. See https://api.0x.org/sources?chainId=<chain_id> with the desired chain's ID for a full list of sources. Separate multiple sources with a comma
     */
    excludedSources?: string
    /**
     * The amount of `sellToken` in `sellToken` base units to sell
     */
    sellAmount: string
    /**
     * The contract address of the token to sell. Native token is not supported
     */
    sellToken: string
    /**
     * The amount in Bps of the `swapFeeToken` to charge and deliver to the `swapFeeRecipient`. You must also specify the `swapFeeRecipient` and `swapFeeToken` in the request to use this feature. For security, this field has a default limit of 1000 Bps. If your application requires a higher value, please reach out to us.
     */
    swapFeeBps?: number
    /**
     * The wallet address to receive the specified trading fees. You must also specify the `swapFeeToken` and `swapFeeBps` in the request to use this feature. Learn more about setting up a trading fee/commission in the FAQs
     */
    swapFeeRecipient?: string
    /**
     * The contract address of the token to receive trading fees in. This must be set to the value of either the `buyToken` or the `sellToken`. You must also specify the `swapFeeRecipient` and `swapFeeBps` in the request to use this feature
     */
    swapFeeToken?: string
    /**
     * The address which holds the `sellToken` balance and has the allowance set for the swap
     */
    taker: string
    /**
     * The address to receive any trade surplus. If specified, this address will receive trade surplus when applicable. Otherwise, the `taker` will receive the surplus
     */
    tradeSurplusRecipient?: string
  }
}

export type GaslessGetQuoteResponse =
  | {
      /**
       * This is the “approval” object which contains the necessary information to process a gasless approval
       */
      approval: {
        type: 'executeMetaTransaction::approve' | 'permit' | 'daiPermit'
        /**
         * The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). If you compute the hash from eip712 field, it should match the value of this field
         */
        hash: string
        /**
         * The necessary data for [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Please don't assume static shapes for `approval.eip712.types`, `approval.eip712.domain`, `approval.eip712.primaryType` and `approval.eip712.message` as they will change depending on the `type`
         */
        eip712: {
          types: {
            [key: string]: Array<{
              name: string
              type: string
            }>
          }
          domain: {
            name?: string
            version?: string
            chainId?: number
            verifyingContract?: string
            salt?: string
          }
          message: {
            [key: string]:
              | string
              | Array<string>
              | number
              | Array<number>
              | boolean
              | Array<boolean>
              | unknown
              | Array<unknown>
          }
          primaryType: string
        }
      } | null
      /**
       * The block number at which the liquidity sources were sampled to generate the quote. This indicates the freshness of the quote.
       */
      blockNumber: unknown & string
      /**
       * The amount of `buyToken` (in `buyToken` units) that will be bought in the swap
       */
      buyAmount: unknown & string
      /**
       * The contract address of the token to buy in the swap
       */
      buyToken: string
      fees: {
        /**
         * The specified fee to charge and deliver to the `swapFeeRecipient`.
         */
        integratorFee: {
          /**
           * The amount of token charged as the integrator fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the integrator fee
           */
          token: string
          type: 'volume'
        } | null
        /**
         * The fee charged by 0x for the trade.
         */
        zeroExFee: {
          /**
           * The amount of token charged as the 0x fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the 0x fee
           */
          token: string
          type: 'volume'
        } | null
        /**
         * The gas fee to be used in submitting the transaction.
         */
        gasFee: {
          /**
           * The amount of token charged as the gas fee
           */
          amount: unknown & string
          /**
           * The address of the token charged as the gas fee
           */
          token: string
          type: 'gas'
        } | null
      }
      /**
       * An object containing potential issues discovered during 0x validation that can prevent the swap from being executed successfully by the `taker`
       */
      issues: {
        /**
         * Details of allowances that the `taker` must set for in order to execute the swap successfully. Null if no allowance is required
         */
        allowance: {
          /**
           * The `taker`'s current allowance of the `spender`
           */
          actual: unknown & string
          /**
           * The address to set the allowance on
           */
          spender: string
        } | null
        /**
         * Details of balance of the `sellToken` that the `taker` must hold. Null if the `taker` has sufficient balance
         */
        balance: {
          /**
           * The contract address of the `sellToken`
           */
          token: string
          /**
           * The current balance of the `sellToken` in the `taker` address
           */
          actual: unknown & string
          /**
           * The balance of the `sellToken` required for the swap to execute successfully
           */
          expected: unknown & string
        } | null
        /**
         * This is set to `true` when 0x cannot validate the transaction. This happens when the `taker` has an insufficient balance of the `sellToken` and 0x is unable to peform ehanced quote validation with the low balance. Note that this does not necessarily mean that the trade will revert
         */
        simulationIncomplete: boolean
        /**
         * A list of invalid sources present in `excludedSources` request. See https://api.0x.org/sources?chainId= with the desired chain's ID for the list of valid sources
         */
        invalidSourcesPassed: Array<string>
      }
      /**
       * This validates the availability of liquidity for the quote requested. The rest of the fields will only be returned if `true`
       */
      liquidityAvailable: boolean
      /**
       * The price which must be met or else the transaction will revert. This price is influenced by the `slippageBps` parameter. On-chain sources may encounter price movements from quote to settlement
       */
      minBuyAmount: unknown & string
      /**
       * The path of liquidity sources to be used in executing this swap
       */
      route: {
        /**
         * Details of each segment that 0x routes the swap through
         */
        fills: Array<{
          /**
           * The contract address of the input token
           */
          from: string
          /**
           * The contract address of the output token
           */
          to: string
          /**
           * The liquidity source used in the route
           */
          source: string
          /**
           * The proportion of the trade to be filled by the `source`
           */
          proportionBps: unknown & string
        }>
        /**
         * Properties of the tokens involved in the swap
         */
        tokens: Array<{
          /**
           * The token address. This is the unique identifier of the token
           */
          address: string
          /**
           * The token symbol. This is not guaranteed to be unique, as multiple tokens can have the same symbol
           */
          symbol: string
        }>
      }
      /**
       * The amount of `sellToken` (in `sellToken` units) that will be sold in this swap
       */
      sellAmount: unknown & string
      /**
       * The contract address of the token to sell in the swap
       */
      sellToken: string
      /**
       * The address of the target contract that the transaction will be submitted to
       */
      target: string
      /**
       * Swap-related metadata for the buy and sell token in the swap
       */
      tokenMetadata: {
        /**
         * Swap-related metadata for the buy token
         */
        buyToken: {
          /**
           * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          buyTaxBps: (unknown & string) | null
          /**
           * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          sellTaxBps: (unknown & string) | null
        }
        /**
         * Swap-related metadata for the sell token
         */
        sellToken: {
          /**
           * The buy tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          buyTaxBps: (unknown & string) | null
          /**
           * The sell tax in bps of the token. Since each token could have arbitrary implementation, this field is best effort, meaning it would be set to `null` if the system is not able to determine the tax
           */
          sellTaxBps: (unknown & string) | null
        }
      }
      /**
       * This is the “trade” object which contains the necessary information to process a gasless trade
       */
      trade: {
        /**
         * The transaction type determined by the trade route. This is currently just `settler_metatransaction` and could expand to more types in the future
         */
        type: 'settler_metatransaction'
        /**
         * The hash for the trade according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). If you compute the hash from eip712 field, it should match the value of this field
         */
        hash: string
        /**
         * This is the necessary data for [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Please don't assume static shapes for `trade.eip712.types`, `trade.eip712.domain`, `trade.eip712.primaryType` and `trade.eip712.message` as they will change depending on the `type`
         */
        eip712: {
          types: {
            [key: string]: Array<{
              name: string
              type: string
            }>
          }
          domain: {
            name?: string
            version?: string
            chainId?: number
            verifyingContract?: string
            salt?: string
          }
          message: {
            [key: string]:
              | string
              | Array<string>
              | number
              | Array<number>
              | boolean
              | Array<boolean>
              | unknown
              | Array<unknown>
          }
          primaryType: string
        }
      }
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }
  | {
      /**
       * This validates the availability of liquidity for the quote requested. No other fields will be returned if it is `false`
       */
      liquidityAvailable: boolean
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }

export type GaslessGetQuoteError =
  | INPUT_INVALID
  | INSUFFICIENT_BALANCE
  | SELL_AMOUNT_TOO_SMALL
  | TOKEN_NOT_SUPPORTED
  | TAKER_NOT_AUTHORIZED_FOR_TRADE
  | BUY_TOKEN_NOT_AUTHORIZED_FOR_TRADE
  | SELL_TOKEN_NOT_AUTHORIZED_FOR_TRADE
  | INTERNAL_SERVER_ERROR
  | UNCATEGORIZED

export type GaslessSubmitData = {
  body: {
    /**
     * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
     */
    chainId: number
    /**
     * The gasless approval object from the quote endpoint including its signature
     */
    approval?: {
      /**
       * The `approval.type` from the quote endpoint
       */
      type: 'executeMetaTransaction::approve' | 'permit' | 'daiPermit'
      eip712:
        | {
            types: {
              EIP712Domain: Array<{
                name: string
                type: string
              }>
              Permit: Array<{
                name: string
                type: string
              }>
            }
            domain: {
              name?: string
              version?: string
              chainId?: number
              verifyingContract?: string
              salt?: string
            }
            message: {
              owner: string
              spender: string
              value: string
              nonce: number
              deadline: string
            }
            primaryType: 'Permit'
          }
        | {
            types: {
              EIP712Domain: Array<{
                name: string
                type: string
              }>
              Permit: Array<{
                name: string
                type: string
              }>
            }
            domain: {
              name?: string
              version?: string
              chainId?: number
              verifyingContract?: string
              salt?: string
            }
            message: {
              holder: string
              spender: string
              nonce: number
              expiry: string
              allowed: boolean
            }
            primaryType: 'Permit'
          }
        | {
            types: {
              EIP712Domain: Array<{
                name: string
                type: string
              }>
              MetaTransaction: Array<{
                name: string
                type: string
              }>
            }
            domain: {
              name?: string
              version?: string
              chainId?: number
              verifyingContract?: string
              salt?: string
            }
            message: {
              nonce: number
              from: string
              functionSignature: string
            }
            primaryType: 'MetaTransaction'
          }
      signature: {
        signatureType: number
        v: number
        r: string
        s: string
      }
    } | null
    /**
     * The trade object from the quote endpoint including its signature
     */
    trade: {
      /**
       * The `trade.type` from the quote endpoint
       */
      type: 'settler_metatransaction'
      /**
       * The `trade.eip712` from the quote endpoint
       */
      eip712: {
        types: {
          [key: string]: Array<{
            name: string
            type: string
          }>
        }
        primaryType: string
        domain: {
          name?: string
          version?: string
          chainId?: number
          verifyingContract?: string
          salt?: string
        }
        message: {
          permitted: {
            token: string
            amount: string | number | unknown
          }
          spender: string
          nonce: string | number | unknown
          deadline: string | number | unknown
          slippageAndActions: {
            recipient: string
            buyToken: string
            minAmountOut: string | number | unknown
            actions: Array<string>
          }
        }
      }
      signature: {
        signatureType: number
        v: number
        r: string
        s: string
      }
    }
  }
  headers: {
    /**
     * Visit dashboard.0x.org to get your API Key
     */
    '0x-api-key': string
  }
}

export type GaslessSubmitResponse = {
  /**
   * The hash for the trade according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712)
   */
  tradeHash: string
  /**
   * The transaction type determined by the trade route. This is currently just `settler_metatransaction` and could expand to more types in the future
   */
  type: 'settler_metatransaction'
  /**
   * The unique ZeroEx identifier of the request
   */
  zid: string
}

export type GaslessSubmitError =
  | INPUT_INVALID
  | INSUFFICIENT_BALANCE_OR_ALLOWANCE
  | INVALID_SIGNATURE
  | INVALID_SIGNER
  | META_TRANSACTION_EXPIRY_TOO_SOON
  | META_TRANSACTION_INVALID
  | PENDING_TRADES_ALREADY_EXIST
  | INTERNAL_SERVER_ERROR
  | UNCATEGORIZED

export type GaslessGetStatusData = {
  headers: {
    /**
     * Visit dashboard.0x.org to get your API Key
     */
    '0x-api-key': string
  }
  path: {
    /**
     * The hash for the trade according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712)
     */
    tradeHash: string
  }
  query: {
    /**
     * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
     */
    chainId: number
  }
}

export type GaslessGetStatusResponse =
  | {
      /**
       * Details of the gasless approval transaction
       */
      approvalTransactions?: Array<{
        /**
         * The onchain transaction hash
         */
        hash: string
        /**
         * The timestamp when the transaction was submitted onchain
         */
        timestamp: number
      }>
      /**
       * `pending` means that the order has been queued on 0x. `submitted` means that it has been submitted onchain,`succeeded` means it has been included in a block and `confirmed` means it has at least 3 confirmations onchain
       */
      status: 'pending' | 'submitted' | 'succeeded' | 'confirmed'
      /**
       * Details of the gasless swap transaction. If the trade is `pending`, no transaction will be returned. If `submitted`, multiple transactions may be returned, but only one will be mined. If `successful` and `confirmed`, the mined transaction will be returned
       */
      transactions: Array<{
        /**
         * The onchain transaction hash
         */
        hash: string
        /**
         * The timestamp when the transaction was submitted onchain
         */
        timestamp: number
      }>
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }
  | {
      /**
       * Details of the gasless approval transaction
       */
      approvalTransactions?: Array<{
        /**
         * The onchain transaction hash
         */
        hash: string
        /**
         * The timestamp when the transaction was submitted onchain
         */
        timestamp: number
      }>
      /**
       * This provides more context about why the transaction failed
       */
      reason:
        | 'transaction_simulation_failed'
        | 'order_expired'
        | 'last_look_declined'
        | 'transaction_reverted'
        | 'market_maker_sigature_error'
        | 'invalid_balance'
        | 'internal_error'
      /**
       * `failed` means that the order failed to be submitted onchain
       */
      status: 'failed'
      /**
       * Details of the gasless swap transaction. If the trade status is `failed`, there may be 0 (if it failed before submission) to multiple transactions (if the transaction reverted)
       */
      transactions: Array<{
        /**
         * The onchain transaction hash
         */
        hash: string
        /**
         * The timestamp when the transaction was submitted onchain
         */
        timestamp: number
      }>
      /**
       * The unique ZeroEx identifier of the request
       */
      zid: string
    }

export type GaslessGetStatusError =
  | INPUT_INVALID
  | META_TRANSACTION_STATUS_NOT_FOUND
  | INTERNAL_SERVER_ERROR
  | UNCATEGORIZED

export type GaslessGetGaslessApprovalTokensData = {
  headers: {
    /**
     * Visit dashboard.0x.org to get your API Key
     */
    '0x-api-key': string
  }
  query: {
    /**
     * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
     */
    chainId: number
  }
}

export type GaslessGetGaslessApprovalTokensResponse = {
  /**
   * The list of tokens that can be used for gasless approvals
   */
  tokens: Array<string>
  /**
   * The unique ZeroEx identifier of the request
   */
  zid: string
}

export type GaslessGetGaslessApprovalTokensError =
  | INPUT_INVALID
  | INTERNAL_SERVER_ERROR
  | UNCATEGORIZED

export type SourcesGetSourcesData = {
  headers: {
    /**
     * Visit dashboard.0x.org to get your API Key
     */
    '0x-api-key': string
  }
  query: {
    /**
     * Chain ID. See [here](https://0x.org/docs/next/developer-resources/supported-chains) for the list of supported chains
     */
    chainId: number
  }
}

export type SourcesGetSourcesResponse = {
  /**
   * The array of liquidity sources aggregated by 0x for the requested chain
   */
  sources: Array<string>
  /**
   * The unique ZeroEx identifier of the request
   */
  zid: string
}

export type SourcesGetSourcesError =
  | INPUT_INVALID
  | INTERNAL_SERVER_ERROR
  | UNCATEGORIZED
